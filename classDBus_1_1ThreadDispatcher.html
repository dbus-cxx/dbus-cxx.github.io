<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dbus-cxx: DBus::ThreadDispatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo"><a href="index.html"><img alt="dbus-cxx Logo" src="dbus-cxx-logo-med.png"/></a></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDBus.html">DBus</a></li><li class="navelem"><a class="el" href="classDBus_1_1ThreadDispatcher.html">ThreadDispatcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDBus_1_1ThreadDispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DBus::ThreadDispatcher Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classDBus_1_1ThreadDispatcher.html" title="A ThreadDispatcher is responsible for executing method calls and signals on objects in the given thre...">ThreadDispatcher</a> is responsible for executing method calls and signals on objects in the given thread.  
 <a href="classDBus_1_1ThreadDispatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="threaddispatcher_8h_source.html">threaddispatcher.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34885529fb85440c36f3e200b429b1d2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1ThreadDispatcher.html#a34885529fb85440c36f3e200b429b1d2">~ThreadDispatcher</a> ()</td></tr>
<tr class="separator:a34885529fb85440c36f3e200b429b1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61813713dc918859ec8b967c49dc3924"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1ThreadDispatcher.html#a61813713dc918859ec8b967c49dc3924">add_message</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt; object, std::shared_ptr&lt; const <a class="el" href="classDBus_1_1CallMessage.html">CallMessage</a> &gt; message)=0</td></tr>
<tr class="memdesc:a61813713dc918859ec8b967c49dc3924"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a new message comes in that needs to be processed, this method is called with the object that the method needs to go to, and the message to send to this object.  <a href="classDBus_1_1ThreadDispatcher.html#a61813713dc918859ec8b967c49dc3924">More...</a><br /></td></tr>
<tr class="separator:a61813713dc918859ec8b967c49dc3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baf443857fb803f837877e542fc92a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1ThreadDispatcher.html#a3baf443857fb803f837877e542fc92a1">add_signal_proxy</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1SignalProxyBase.html">SignalProxyBase</a> &gt; handler)=0</td></tr>
<tr class="memdesc:a3baf443857fb803f837877e542fc92a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a signal proxy that must emit its signals from the thread represented by this <a class="el" href="classDBus_1_1ThreadDispatcher.html" title="A ThreadDispatcher is responsible for executing method calls and signals on objects in the given thre...">ThreadDispatcher</a>.  <a href="classDBus_1_1ThreadDispatcher.html#a3baf443857fb803f837877e542fc92a1">More...</a><br /></td></tr>
<tr class="separator:a3baf443857fb803f837877e542fc92a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8debcf8034c5f8b024d01e67e8b2ef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1ThreadDispatcher.html#a4d8debcf8034c5f8b024d01e67e8b2ef">remove_signal_proxy</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1SignalProxyBase.html">SignalProxyBase</a> &gt; handler)=0</td></tr>
<tr class="memdesc:a4d8debcf8034c5f8b024d01e67e8b2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a signal proxy.  <a href="classDBus_1_1ThreadDispatcher.html#a4d8debcf8034c5f8b024d01e67e8b2ef">More...</a><br /></td></tr>
<tr class="separator:a4d8debcf8034c5f8b024d01e67e8b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366fff3dcf47b8097132b8e36165fea9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1ThreadDispatcher.html#a366fff3dcf47b8097132b8e36165fea9">add_signal</a> (std::shared_ptr&lt; const <a class="el" href="classDBus_1_1SignalMessage.html">SignalMessage</a> &gt; message)=0</td></tr>
<tr class="memdesc:a366fff3dcf47b8097132b8e36165fea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a new signal message comes in that needs to be processed, this method is called with the <a class="el" href="classDBus_1_1SignalMessage.html" title="Represents a DBus signal message.">SignalMessage</a> that must be emitted from this thread.  <a href="classDBus_1_1ThreadDispatcher.html#a366fff3dcf47b8097132b8e36165fea9">More...</a><br /></td></tr>
<tr class="separator:a366fff3dcf47b8097132b8e36165fea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classDBus_1_1ThreadDispatcher.html" title="A ThreadDispatcher is responsible for executing method calls and signals on objects in the given thre...">ThreadDispatcher</a> is responsible for executing method calls and signals on objects in the given thread. </p>
<p>If you are using the standard <a class="el" href="classDBus_1_1Dispatcher.html" title="A Dispatcher handles all of the reading/writing that a Connection needs in order to work correctly.">DBus::Dispatcher</a> class, you can either run all method calls in the dispatcher thread, and create a <a class="el" href="classDBus_1_1ThreadDispatcher.html" title="A ThreadDispatcher is responsible for executing method calls and signals on objects in the given thre...">ThreadDispatcher</a> in the main thread with a main loop.</p>
<p>If you're using Qt, link with dbus-cxx-qt and use the QtThreadDispatcher class.</p>
<p>If you're using GLib, link with dbus-cxx-glib and use the GLibThreadDispatcher class.</p>
<p>Note that all methods in this class are called from the dispatcher thread. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a34885529fb85440c36f3e200b429b1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34885529fb85440c36f3e200b429b1d2">&#9670;&nbsp;</a></span>~ThreadDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ThreadDispatcher::~ThreadDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61813713dc918859ec8b967c49dc3924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61813713dc918859ec8b967c49dc3924">&#9670;&nbsp;</a></span>add_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DBus::ThreadDispatcher::add_message </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classDBus_1_1CallMessage.html">CallMessage</a> &gt;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a new message comes in that needs to be processed, this method is called with the object that the method needs to go to, and the message to send to this object. </p>
<p>Generally, this method should push the object/message onto some sort of mutex-locked queue and then wakeup this thread. The thread will then lock the mutex, pop an element off of the queue, and direct the message to the given object via the handle_message method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The object to send the message to </td></tr>
    <tr><td class="paramname">message</td><td>The message to send to the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366fff3dcf47b8097132b8e36165fea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366fff3dcf47b8097132b8e36165fea9">&#9670;&nbsp;</a></span>add_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DBus::ThreadDispatcher::add_signal </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classDBus_1_1SignalMessage.html">SignalMessage</a> &gt;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a new signal message comes in that needs to be processed, this method is called with the <a class="el" href="classDBus_1_1SignalMessage.html" title="Represents a DBus signal message.">SignalMessage</a> that must be emitted from this thread. </p>
<p>Generally, this method should push the SignalMesage onto some sort of mutex-locked queue and then wakeup this thread. This thread will then lock the mutex, pop an element off of the queue, and loop through all of the signal proxys (added via add_signal_proxy) and calling the <a class="el" href="classDBus_1_1SignalProxyBase.html#af3bb79f386456fc98c3237109178a1ba">SignalProxyBase::handle_signal</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to be emitted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3baf443857fb803f837877e542fc92a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baf443857fb803f837877e542fc92a1">&#9670;&nbsp;</a></span>add_signal_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DBus::ThreadDispatcher::add_signal_proxy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1SignalProxyBase.html">SignalProxyBase</a> &gt;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a signal proxy that must emit its signals from the thread represented by this <a class="el" href="classDBus_1_1ThreadDispatcher.html" title="A ThreadDispatcher is responsible for executing method calls and signals on objects in the given thre...">ThreadDispatcher</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler that can handle incoming signals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8debcf8034c5f8b024d01e67e8b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8debcf8034c5f8b024d01e67e8b2ef">&#9670;&nbsp;</a></span>remove_signal_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DBus::ThreadDispatcher::remove_signal_proxy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1SignalProxyBase.html">SignalProxyBase</a> &gt;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a signal proxy. </p>
<p>Note that it is possible that this method is called with a signal_proxy_base that has not been previously added with add_signal_proxy; this is not an error and should not cause unintended consequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signal proxy was removed, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="threaddispatcher_8h_source.html">threaddispatcher.h</a></li>
<li><a class="el" href="threaddispatcher_8cpp.html">threaddispatcher.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 7 2023 15:36:56 for dbus-cxx by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
