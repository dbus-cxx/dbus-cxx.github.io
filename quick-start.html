<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dbus-cxx: Quick-start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<link rel="shortcut icon" href="favicon.ico" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dbus-cxx-logo-doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dbus-cxx
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('quick-start.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Quick-start </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md12">Using dbus-cxx with your build system</a><ul><li class="level2"><a href="#autotoc_md13">pkg-config files</a></li>
<li class="level2"><a href="#autotoc_md14">CMake + dbus-cxx</a></li>
<li class="level2"><a href="#autotoc_md15">qmake + dbus-cxx</a></li>
<li class="level2"><a href="#autotoc_md16">Autotools + dbus-cxx</a></li>
</ul>
</li>
<li class="level1"><a href="#quick_start_initial_concepts">Initial Concepts</a><ul><li class="level2"><a href="#autotoc_md17">sigc++ signal and slot library</a><ul><li class="level3"><a href="#autotoc_md18">Free Functions</a></li>
<li class="level3"><a href="#autotoc_md19">Member Functions</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md20">Smart pointers and create()</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md21">Quick-start example</a><ul><li class="level2"><a href="#autotoc_md22">Server code</a><ul><li class="level3"><a href="#autotoc_md23">Summary</a></li>
<li class="level3"><a href="#autotoc_md24">Simple server 0 code discussion</a></li>
<li class="level3"><a href="#autotoc_md25">Create a dispatcher to manage threads, timeouts and I/O watches</a></li>
<li class="level3"><a href="#autotoc_md26">Create a connection to the D-Bus session bus</a></li>
<li class="level3"><a href="#autotoc_md27">Request a name for our application on the bus</a></li>
<li class="level3"><a href="#autotoc_md28">Create an object on the bus</a></li>
<li class="level3"><a href="#autotoc_md29">Add a method named add to our object</a></li>
<li class="level3"><a href="#autotoc_md30">Wait for incoming calls</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md31">Client code</a><ul><li class="level3"><a href="#autotoc_md32">Include headers</a></li>
<li class="level3"><a href="#autotoc_md33">Initializing the Dispatcher and Connection</a></li>
<li class="level3"><a href="#autotoc_md34">Creating a Proxy object</a></li>
<li class="level3"><a href="#autotoc_md35">Call our proxy method</a></li>
<li class="level3"><a href="#autotoc_md36">Print out the results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md__home_robert_dbus_cxx_doc_10_quick_start"></a></p>
<p >Once you have installed dbus-cxx, you are now ready to start using it! If you're unfamiliar with <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a> in general, you should read <a href="https://rm5248.com/d-bus-tutorial/">https://rm5248.com/d-bus-tutorial/</a> first.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Using dbus-cxx with your build system</h1>
<p >The first thing that you must do is to properly setup your build system in order to properly find and link with the dbus-cxx library. This varies depending on the buildsystem that you use, but here are some general directions.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
pkg-config files</h2>
<p >When you build and install dbus-cxx, there are several pkg-config files that are provided. They are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">.pc file   </th><th class="markdownTableHeadNone">Used for    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dbus-cxx-2.0.pc   </td><td class="markdownTableBodyNone">Using the library directly. If you're not using a framework/library, this is what you want to use    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dbus-cxx-qt-2.0.pc   </td><td class="markdownTableBodyNone">Integrating dbus-cxx with Qt. Depends on dbus-cxx-2.0.pc    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dbus-cxx-glib-2.0.pc   </td><td class="markdownTableBodyNone">Integrating dbus-cxx with GLib. Depends on dbus-cxx-2.0.pc   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md14"></a>
CMake + dbus-cxx</h2>
<p >There are two ways to configure your CMake build to use dbus-cxx. The first way is to use the pkg-config files with the <code>FindPkgConfig</code> module. To do this, simply add the following lines to your CMakeLists.txt:</p>
<div class="fragment"><div class="line">include( FindPkgConfig )</div>
<div class="line">pkg_check_modules( dbus-cxx REQUIRED IMPORTED_TARGET dbus-cxx-2.0 )</div>
<div class="line"> </div>
<div class="line">target_link_libraries( exe PkgConfig::dbus-cxx )</div>
</div><!-- fragment --><p >If you want to use the <code>find_package</code> directive of CMake, your CMakeLists.txt file should look something like the following:</p>
<div class="fragment"><div class="line">include( FindPkgConfig )</div>
<div class="line">pkg_check_modules( sigc REQUIRED IMPORTED_TARGET sigc++-3.0 )</div>
<div class="line">find_package( dbus-cxx REQUIRED )</div>
<div class="line">find_package( Threads )</div>
<div class="line"> </div>
<div class="line">target_link_libraries( exe dbus-cxx::dbus-cxx Threads::Threads PkgConfig::sigc )</div>
</div><!-- fragment --><p >Note that you need to use both pkg-config and the <code>find_package</code> directive, because libsigc++ does not provide a CMake package at this point.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
qmake + dbus-cxx</h2>
<p >Because of Qt's signal/slot mechanism, dbus-cxx will not work directly with Qt. Assuming that you are using QMake, you will need to add the following lines to your .pro file: </p><div class="fragment"><div class="line">CONFIG += no_keywords</div>
<div class="line">unix:CONFIG += link_pkgconfig</div>
<div class="line">unix:PKGCONFIG += dbus-cxx-qt-2.0</div>
</div><!-- fragment --><p> Note that this will also allow you to use the Qt integration with dbus-cxx.</p>
<p >At any point in your Qt program, you need to use Qt signals or slots, use the macros Q_SIGNALS or Q_SLOTS to define your signals/slots.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Autotools + dbus-cxx</h2>
<p >If you are using autotools, modify configure.ac (or configure.in ) with the following lines: </p><div class="fragment"><div class="line">PKG_CHECK_MODULES(PROJECT_DBUSCXX,[dbus-cxx-2.0 &gt;= 2.0.0])</div>
<div class="line">AC_SUBST(PROJECT_DBUSCXX_LIBS)</div>
<div class="line">AC_SUBST(PROJECT_DBUSCXX_CFLAGS)</div>
</div><!-- fragment --><p >You can then use the symbols <code>PROJECT_DBUSCXX_LIBS</code> and <code>PROJECT_DBUSCXX_CFLAGS</code> in your Makefile.am files. For example, if you have a application named fooapp your Makefile.am might look like this: </p><div class="fragment"><div class="line">INCLUDES = $(PROJECT_DBUSCXX_CFLAGS)</div>
<div class="line">bin_PROGRAMS = fooapp</div>
<div class="line">fooapp_SOURCES = fooapp.cpp</div>
<div class="line">fooapp_LDADD = $(PROJECT_DBUSCXX_LIBS)</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_start_initial_concepts"></a>
Initial Concepts</h1>
<p >A dbus-cxx <a class="el" href="classDBus_1_1Object.html">Object</a> is a collection of methods and signals. A method is an operation that may be invoked on a object and may or may not return a value. A signal is emitted by the object and does not have a return value.</p>
<p >A dbus-cxx <a class="el" href="classDBus_1_1ObjectProxy.html">ObjectProxy</a> provides an abstration of a remote Object to a client application. The ObjectProxy provides method and signal proxies that have signatures equivalent to their server-side counterparts.</p>
<p >A <a class="el" href="classDBus_1_1MethodProxy.html">method proxy</a> assembles the parameters of the method call into a D-Bus message and transmits to the server. The response (if any) is returned in the form of a D-Bus message which is then unpacked and returned to the application as the return value from the proxy call.</p>
<p >A <a class="el" href="classDBus_1_1SignalProxy.html">signal proxy</a> is different from a method proxy in that it watches an Object for signal events. These signal events arrive as a D-Bus signal message. When a signal event arrives the parameters are unpacked and emitted locally through the signal proxy callback.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
sigc++ signal and slot library</h2>
<p >dbus-cxx relies heavily on libsigc++'s signal and slot system for both Objects and their proxies.</p>
<p >On the server side and object's methods rely upon slots to provide the underlying functionality. When an incoming method call is invoked, the parameters of the call are unpacked and passed to the slot associated with the method.</p>
<p >Slots are similar to function pointers in C, but can also be a method of a specific class.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Free Functions</h3>
<p >Let's say that we have a free function that we want to have called:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(){</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Hello foo!\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >We would then connect this function using the <code>sigc::ptr_fun()</code> method like so:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Object&gt; obj =</div>
<div class="line">        <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a>-&gt;create_object( <span class="stringliteral">&quot;/foo/bar&quot;</span>, <a class="code hl_enumvalue" href="namespaceDBus.html#afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa">DBus::ThreadForCalling::DispatcherThread</a> );</div>
<div class="line"> </div>
<div class="line">obj-&gt;create_method&lt;void()&gt;( <span class="stringliteral">&quot;what.blah&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>, sigc::ptr_fun( foo ) );</div>
<div class="ttc" id="anamespaceDBus_html_afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa"><div class="ttname"><a href="namespaceDBus.html#afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa">DBus::ThreadForCalling::DispatcherThread</a></div><div class="ttdeci">@ DispatcherThread</div><div class="ttdoc">Always call methods for this object from the dispatcher thread.</div></div>
<div class="ttc" id="arecursive-signal-test-qt_8cpp_html_a4256240e08bc2043e1c1e6984478d0d6"><div class="ttname"><a href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a></div><div class="ttdeci">static std::shared_ptr&lt; DBus::Connection &gt; conn</div><div class="ttdef"><b>Definition:</b> recursive-signal-test-qt.cpp:30</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Member Functions</h3>
<p >If we have a function on a class that we want to call instead, we use <code>sigc::mem_fun</code> in order to connect this code to be called. Assuming something similar as above, our code may look something like the following:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foobar {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> foo(){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Hello Foobar::foo!\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(){</div>
<div class="line">    Foobar f;</div>
<div class="line">    std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = <a class="code hl_function" href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a>();</div>
<div class="line">    std::shared_ptr&lt;DBus::Connection&gt; connection = dispatcher-&gt;create_connection( <a class="code hl_enumvalue" href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a> );</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;DBus::Object&gt; obj =</div>
<div class="line">          connection-&gt;create_object( <span class="stringliteral">&quot;/foo/bar&quot;</span>, <a class="code hl_enumvalue" href="namespaceDBus.html#afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa">DBus::ThreadForCalling::DispatcherThread</a> );</div>
<div class="line">    obj-&gt;create_method&lt;void()&gt;( <span class="stringliteral">&quot;what.blah&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>, sigc::mem_fun(f, &amp;Foobar::foo) );</div>
<div class="line"> </div>
<div class="line">    connection-&gt;request_name( <span class="stringliteral">&quot;dbuscxx.foo.bar&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    std::this_thread::sleep_for( std::chrono::seconds( 30 ) );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDBus_1_1StandaloneDispatcher_html_afcbb3d280095b1254835c580a9c5e7db"><div class="ttname"><a href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a></div><div class="ttdeci">static std::shared_ptr&lt; StandaloneDispatcher &gt; create(bool is_running=true)</div><div class="ttdef"><b>Definition:</b> standalonedispatcher.cpp:66</div></div>
<div class="ttc" id="aglib-caller_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> glib-caller.cpp:23</div></div>
<div class="ttc" id="anamespaceDBus_html_a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1"><div class="ttname"><a href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a></div><div class="ttdeci">@ SESSION</div><div class="ttdoc">The login session bus.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Smart pointers and create()</h2>
<p >DBus-cxx makes extensive use of smart pointers to help manage the memory of a class. In order for this scheme to work properly, most classes cannot be initialized on their own(constructors are private). To create an instance of a class, use the <code>create()</code> method on that class:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Dispatcher&gt; disp = DBus::StandaloneDispatcher::create();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
Quick-start example</h1>
<p >This example will demonstrate a simple server and client pair.</p>
<p >The server will only offer one method named add that will take two double parameters and return the sum as a double.</p>
<p >The client will use a proxy object for the server as well as a proxy for the add method.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Server code</h2>
<p >This section provides an example of a simple server. The server will run for 10 seconds and then automatically shut-down.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Summary</h3>
<p >This is an overview of the code we will need in our example server:</p><ul>
<li>Include headers</li>
<li>Create a dispatcher to manage threads, timeouts and I/O watches</li>
<li>Create a connection to the D-Bus session bus</li>
<li>Request a name for our application on the bus</li>
<li>Create an object on the bus</li>
<li>Add a method named <code>add</code> to our object</li>
<li>Wait for incoming calls</li>
</ul>
<p >Here is the code in full, followed by a section-by-section discussion.</p>
<div class="fragment"><div class="line"><span class="comment">// SPDX-License-Identifier: LGPL-3.0-or-later OR BSD-3-Clause</span></div>
<div class="line"><span class="comment">/***************************************************************************</span></div>
<div class="line"><span class="comment"> *   Copyright (C) 2008,2010 by Rick L. Vinyard, Jr.                       *</span></div>
<div class="line"><span class="comment"> *   rvinyard@cs.nmsu.edu                                                  *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *   This file is part of the dbus-cxx library.                            *</span></div>
<div class="line"><span class="comment"> ***************************************************************************/</span></div>
<div class="line"><span class="preprocessor">#include &lt;dbus-cxx.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> add( <span class="keywordtype">double</span> param1, <span class="keywordtype">double</span> param2 )      { <span class="keywordflow">return</span> param1 + param2; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">  std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = <a class="code hl_function" href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a>();</div>
<div class="line"> </div>
<div class="line">  std::shared_ptr&lt;DBus::Connection&gt; <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a> = dispatcher-&gt;create_connection(<a class="code hl_enumvalue" href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a>);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span>( <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a>-&gt;request_name( <span class="stringliteral">&quot;dbuscxx.quickstart_0.server&quot;</span>, <a class="code hl_define" href="connection_8h.html#a228d4a978d82ef9b12e80feaf50fc14e">DBUSCXX_NAME_FLAG_REPLACE_EXISTING</a> ) != <a class="code hl_enumvalue" href="namespaceDBus.html#a7e5425c1e75f90d2898e0b51acb794d6a88e1e363f68876c924161364974cbd26">DBus::RequestNameResponse::PrimaryOwner</a> )</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//create an object that will contain methods that can be called</span></div>
<div class="line">  std::shared_ptr&lt;DBus::Object&gt; <span class="keywordtype">object</span> = <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a>-&gt;create_object(<span class="stringliteral">&quot;/dbuscxx/quickstart_0&quot;</span>, <a class="code hl_enumvalue" href="namespaceDBus.html#afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa">DBus::ThreadForCalling::DispatcherThread</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//add a method that can be called over the dbus</span></div>
<div class="line">  <span class="keywordtype">object</span>-&gt;create_method&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;(<span class="stringliteral">&quot;dbuscxx.Quickstart&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>, sigc::ptr_fun(add) );</div>
<div class="line"> </div>
<div class="line">  std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconnection_8h_html_a228d4a978d82ef9b12e80feaf50fc14e"><div class="ttname"><a href="connection_8h.html#a228d4a978d82ef9b12e80feaf50fc14e">DBUSCXX_NAME_FLAG_REPLACE_EXISTING</a></div><div class="ttdeci">#define DBUSCXX_NAME_FLAG_REPLACE_EXISTING</div><div class="ttdoc">Same as DBUS_NAME_FLAG_REPLACE_EXISTING.</div><div class="ttdef"><b>Definition:</b> connection.h:32</div></div>
<div class="ttc" id="anamespaceDBus_html_a7e5425c1e75f90d2898e0b51acb794d6a88e1e363f68876c924161364974cbd26"><div class="ttname"><a href="namespaceDBus.html#a7e5425c1e75f90d2898e0b51acb794d6a88e1e363f68876c924161364974cbd26">DBus::RequestNameResponse::PrimaryOwner</a></div><div class="ttdeci">@ PrimaryOwner</div><div class="ttdoc">The caller is now the primary owner.</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Simple server 0 code discussion</h3>
<p >First, we need to include the main dbus-cxx library header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dbus-cxx.h&gt;</span></div>
</div><!-- fragment --><p >Then we will define a function that will be our workhorse on the server side. This function will be the actual function that will be called when the dbus <code>add</code> method is invoked, so we will name our function similarly. But, note that the actual name of the function in our program and the name in our dbus server do not have to match. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> add( <span class="keywordtype">double</span> param1, <span class="keywordtype">double</span> param2 )      { <span class="keywordflow">return</span> param1 + param2; }</div>
</div><!-- fragment --><p >And now for the beginning of our <code><a class="el" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a></code> function. We'll also declare a variable <code>ret</code> that can be used to check the return value of functions. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> ret;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Create a dispatcher to manage threads, timeouts and I/O watches</h3>
<p >Now, we will create a dispatcher to handle incoming and outgoing messages. Handling incoming and outgoing messages can be messy and the Dispatcher class handles much of this for us.</p>
<p >Since this is just a standalone example, we will use the standalone dispatcher</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = <a class="code hl_function" href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a>();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Create a connection to the D-Bus session bus</h3>
<p >Now that we have a dispatcher we need to create a connection to the session bus. </p><div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Connection&gt; <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a> = dispatcher-&gt;create_connection(<a class="code hl_enumvalue" href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
Request a name for our application on the bus</h3>
<p >Next, we need to request a name that will identify our application on the session bus. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a>-&gt;request_name( <span class="stringliteral">&quot;dbuscxx.quickstart_0.server&quot;</span>, <a class="code hl_define" href="connection_8h.html#a228d4a978d82ef9b12e80feaf50fc14e">DBUSCXX_NAME_FLAG_REPLACE_EXISTING</a> ) != <a class="code hl_enumvalue" href="namespaceDBus.html#a7e5425c1e75f90d2898e0b51acb794d6a88e1e363f68876c924161364974cbd26">DBus::RequestNameResponse::PrimaryOwner</a> )</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
Create an object on the bus</h3>
<p >Now that our application has a name on the bus we need to add an object with its path. </p><div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Object&gt; <span class="keywordtype">object</span> = <a class="code hl_variable" href="recursive-signal-test-qt_8cpp.html#a4256240e08bc2043e1c1e6984478d0d6">conn</a>-&gt;create_object(<span class="stringliteral">&quot;/dbuscxx/quickstart_0&quot;</span>, <a class="code hl_enumvalue" href="namespaceDBus.html#afe27044063df28784038ce01c2e7f525a5e4ad822bb12635d22f90ab2259ff7fa">DBus::ThreadForCalling::DispatcherThread</a>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
Add a method named add to our object</h3>
<p >We will now create a method named <code>add</code> for our object. The functionality of the method will be provided by the function we declared above also named <code>add()</code>. We must add this to an interface, and the D-Bus specification required that interface names must contain at least one <code>.</code> (period) character so we will use the interface name <code>"dbuscxx.Quickstart"</code>.</p>
<p >Note that our <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a> object method named <code>add</code> has nothing to do with C++ class methods. In essence we are creating virtual objects on the D-Bus and can choose to provide their functionality with either C++ class methods and/or plain functions. </p><div class="fragment"><div class="line"><span class="keywordtype">object</span>-&gt;create_method&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;(<span class="stringliteral">&quot;dbuscxx.Quickstart&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>, sigc::ptr_fun(add) );</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md30"></a>
Wait for incoming calls</h3>
<p >Finally, we need to wait for incoming calls. We will sleep for 10 seconds in our <code><a class="el" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a></code> function and the calls will be handled in the dispatcher's threads. </p><div class="fragment"><div class="line">  std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Client code</h2>
<p >This section provides an example of a simple client for our simple server.</p>
<p >This is an overview of the code we will need in our example client:</p><ul>
<li>Include headers</li>
<li>Create a dispatcher to manage threads, timeouts and I/O watches</li>
<li>Create a connection to the D-Bus session bus</li>
<li>Create a proxy object for the server's <code>quickstart_0</code> object</li>
<li>Create a proxy <code>add</code> method for our proxy object</li>
<li>Call our proxy method</li>
<li>Print out the results</li>
</ul>
<p >Here is the code in full, followed by a section-by-section discussion.</p>
<div class="fragment"><div class="line"><span class="comment">// SPDX-License-Identifier: LGPL-3.0-or-later OR BSD-3-Clause</span></div>
<div class="line"><span class="comment">/***************************************************************************</span></div>
<div class="line"><span class="comment"> *   Copyright (C) 2008,2010 by Rick L. Vinyard, Jr.                       *</span></div>
<div class="line"><span class="comment"> *   rvinyard@cs.nmsu.edu                                                  *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *   This file is part of the dbus-cxx library.                            *</span></div>
<div class="line"><span class="comment"> ***************************************************************************/</span></div>
<div class="line"><span class="preprocessor">#include &lt;dbus-cxx.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="glib-caller_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">  std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = <a class="code hl_function" href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a>();</div>
<div class="line"> </div>
<div class="line">  std::shared_ptr&lt;DBus::Connection&gt; connection = dispatcher-&gt;create_connection( <a class="code hl_enumvalue" href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a> );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//create an object proxy, which stands in for a real object.</span></div>
<div class="line">  <span class="comment">//a proxy exists over the dbus</span></div>
<div class="line">  std::shared_ptr&lt;DBus::ObjectProxy&gt; <span class="keywordtype">object</span> = connection-&gt;create_object_proxy(<span class="stringliteral">&quot;dbuscxx.quickstart_0.server&quot;</span>, <span class="stringliteral">&quot;/dbuscxx/quickstart_0&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//a method proxy acts like a real method, but will go over the dbus</span></div>
<div class="line">  <span class="comment">//to do its work.</span></div>
<div class="line">  <a class="code hl_class" href="classDBus_1_1MethodProxy.html">DBus::MethodProxy</a>&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;&amp; add_proxy</div>
<div class="line">    = *(<span class="keywordtype">object</span>-&gt;create_method&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;(<span class="stringliteral">&quot;dbuscxx.Quickstart&quot;</span>,<span class="stringliteral">&quot;add&quot;</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> answer;</div>
<div class="line">  <span class="comment">// Call the method over the bus.  This blocks by default.</span></div>
<div class="line">  answer = add_proxy( 1.1, 2.2 );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;1.1 + 2.2 = &quot;</span> &lt;&lt; answer &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDBus_1_1MethodProxy_html"><div class="ttname"><a href="classDBus_1_1MethodProxy.html">DBus::MethodProxy</a></div><div class="ttdef"><b>Definition:</b> interfaceproxy.h:30</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Include headers</h3>
<p >First, we need to include the main dbus-cxx library header. We'll also include the <code>iostream</code> header since we'll print out the results of our addition. </p><div class="fragment"><div class="line">#include &lt;dbus-cxx.h&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md33"></a>
Initializing the Dispatcher and Connection</h3>
<p >Now, we will create a dispatcher to handle incoming and outgoing messages. Handling incoming and outgoing messages can be messy and the Dispatcher class handles much of this for us. Because this is a standalone example, we will use a StandloneDispatcher to do all of this work for us. </p><div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = <a class="code hl_function" href="classDBus_1_1StandaloneDispatcher.html#afcbb3d280095b1254835c580a9c5e7db">DBus::StandaloneDispatcher::create</a>();</div>
</div><!-- fragment --><p >Now that we have a dispatcher we need to create a connection to the session bus. </p><div class="fragment"><div class="line">std::shared_ptr&lt;DBus::Connection&gt; connection = dispatcher-&gt;create_connection( <a class="code hl_enumvalue" href="namespaceDBus.html#a65a7f3cf99252b69858cd12817d2b764a8e32a82fa7897baa1c7f2bbf920b0ff1">DBus::BusType::SESSION</a> );</div>
</div><!-- fragment --><p> Note that unlike the server example, we do not request a name on the bus. This is because we do not need to have a well-known name on the bus in order to call methods on other objects.</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Creating a Proxy object</h3>
<p >You'll notice that up to this point the code for the client and the server has been very similar. This is the point at which they will diverge. We will now create a proxy object for the object on the server. </p><div class="fragment"><div class="line">std::shared_ptr&lt;DBus::ObjectProxy&gt; <span class="keywordtype">object</span> = connection-&gt;create_object_proxy(<span class="stringliteral">&quot;dbuscxx.quickstart_0.server&quot;</span>, <span class="stringliteral">&quot;/dbuscxx/quickstart_0&quot;</span>);</div>
</div><!-- fragment --><p> Note that we must use the name the server requested as well as the object path the server used when it created its object when we create the proxy object.</p>
<p >Now we create a proxy <code>add</code> method for the server object's <code>add</code> method. This will allow us to use function notation to call the method. When creating the proxy method we must use the same interface ( <code>"dbuscxx.Quickstart"</code> ) and method name ( <code>"add"</code> ) as the server used. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classDBus_1_1MethodProxy.html">DBus::MethodProxy</a>&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;&amp; add_proxy</div>
<div class="line">    = *(<span class="keywordtype">object</span>-&gt;create_method&lt;double(<span class="keywordtype">double</span>,<span class="keywordtype">double</span>)&gt;(<span class="stringliteral">&quot;dbuscxx.Quickstart&quot;</span>,<span class="stringliteral">&quot;add&quot;</span>));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
Call our proxy method</h3>
<p >Now we can use our proxy method to call the method on the server using function notation. We'll keep things simple and just add <code>1.1</code> + <code>2.2</code> . </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> answer;</div>
<div class="line">answer = add_proxy( 1.1, 2.2 );</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36"></a>
Print out the results</h3>
<p >Finally, we can print out the results. </p><div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;1.1 + 2.2 = &quot;</span> &lt;&lt; answer &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<p> The following pages provide the quick-start for dbus-cxx:</p>
<ol type="1">
<li>quick_start_client_0.md</li>
<li>quick_start_cmake.md</li>
<li>quick_start_example_0.md</li>
<li>quick_start_initial_concepts.md</li>
<li>quick_start.md</li>
<li>quick_start_pkgconfig.md</li>
<li>quick_start_server_0.md </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
