<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dbus-cxx: DBus::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo"><a href="index.html"><img alt="dbus-cxx Logo" src="dbus-cxx-logo-med.png"/></a></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDBus.html">DBus</a></li><li class="navelem"><a class="el" href="classDBus_1_1Object.html">Object</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classDBus_1_1Object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DBus::Object Class Reference<div class="ingroups"><a class="el" href="group__local.html">Local Objects</a> &#124; <a class="el" href="group__objects.html">Objects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> represents a local object that is able to be called over the <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a>.  
 <a href="classDBus_1_1Object.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="object_8h_source.html">object.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e663be287217ecddb85029b88903193"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193">Interfaces</a></td></tr>
<tr class="memdesc:a9e663be287217ecddb85029b88903193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a></code> instance's interfaces.  <a href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193">More...</a><br /></td></tr>
<tr class="separator:a9e663be287217ecddb85029b88903193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69552bbf95f68bc043314035bd3d5001"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001">Children</a></td></tr>
<tr class="memdesc:a69552bbf95f68bc043314035bd3d5001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a></code> instance's children.  <a href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001">More...</a><br /></td></tr>
<tr class="separator:a69552bbf95f68bc043314035bd3d5001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22eb06f7f4cbed84f434d8a26b56dded"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a22eb06f7f4cbed84f434d8a26b56dded">~Object</a> ()</td></tr>
<tr class="separator:a22eb06f7f4cbed84f434d8a26b56dded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba3d2f5de59cade1c5ed13a85f7571c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path</a> () const</td></tr>
<tr class="memdesc:a1ba3d2f5de59cade1c5ed13a85f7571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path this handler is associated with.  <a href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">More...</a><br /></td></tr>
<tr class="separator:a1ba3d2f5de59cade1c5ed13a85f7571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ff214b1e5681fd4272b050d3b02c8"><td class="memItemLeft" align="right" valign="top">std::weak_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">connection</a> () const</td></tr>
<tr class="memdesc:ae45ff214b1e5681fd4272b050d3b02c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connection this handler is registered with.  <a href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">More...</a><br /></td></tr>
<tr class="separator:ae45ff214b1e5681fd4272b050d3b02c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec64de5d749247e31d3721747a02f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a91ec64de5d749247e31d3721747a02f5">unregister</a> ()</td></tr>
<tr class="memdesc:a91ec64de5d749247e31d3721747a02f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the handler.  <a href="classDBus_1_1Object.html#a91ec64de5d749247e31d3721747a02f5">More...</a><br /></td></tr>
<tr class="separator:a91ec64de5d749247e31d3721747a02f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c21d2278f15401bbb11b0058ea0848f"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;) &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7c21d2278f15401bbb11b0058ea0848f">signal_registered</a> ()</td></tr>
<tr class="memdesc:a7c21d2278f15401bbb11b0058ea0848f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when this object is registered with a connection.  <a href="classDBus_1_1Object.html#a7c21d2278f15401bbb11b0058ea0848f">More...</a><br /></td></tr>
<tr class="separator:a7c21d2278f15401bbb11b0058ea0848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6966d3202df526077529066c1169540"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;) &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac6966d3202df526077529066c1169540">signal_unregistered</a> ()</td></tr>
<tr class="memdesc:ac6966d3202df526077529066c1169540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when this object is unregistered from a connection.  <a href="classDBus_1_1Object.html#ac6966d3202df526077529066c1169540">More...</a><br /></td></tr>
<tr class="separator:ac6966d3202df526077529066c1169540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84d5b62de8ad526e19c8af7c442b72d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa84d5b62de8ad526e19c8af7c442b72d">set_connection</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; conn)</td></tr>
<tr class="memdesc:aa84d5b62de8ad526e19c8af7c442b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the connection that this object is on.  <a href="classDBus_1_1Object.html#aa84d5b62de8ad526e19c8af7c442b72d">More...</a><br /></td></tr>
<tr class="separator:aa84d5b62de8ad526e19c8af7c442b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4359771c176e0bb0b38988c7616ca8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193">Interfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a4e4359771c176e0bb0b38988c7616ca8">interfaces</a> () const</td></tr>
<tr class="memdesc:a4e4359771c176e0bb0b38988c7616ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> instance.  <a href="classDBus_1_1Object.html#a4e4359771c176e0bb0b38988c7616ca8">More...</a><br /></td></tr>
<tr class="separator:a4e4359771c176e0bb0b38988c7616ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f36549d94e97943656238b6998c3b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aa77f36549d94e97943656238b6998c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interface with the given name.  <a href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">More...</a><br /></td></tr>
<tr class="separator:aa77f36549d94e97943656238b6998c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772bd922bdd031f7745658429c34ff4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a772bd922bdd031f7745658429c34ff4f">add_interface</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; <a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name</a>)</td></tr>
<tr class="memdesc:a772bd922bdd031f7745658429c34ff4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the interface to this object.  <a href="classDBus_1_1Object.html#a772bd922bdd031f7745658429c34ff4f">More...</a><br /></td></tr>
<tr class="separator:a772bd922bdd031f7745658429c34ff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14192b7048cf58735b2ded8e83718f17"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a14192b7048cf58735b2ded8e83718f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds the named interface to this object.  <a href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">More...</a><br /></td></tr>
<tr class="separator:a14192b7048cf58735b2ded8e83718f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19937e2850bf14c1fe3ac79109f8870"><td class="memTemplParams" colspan="2">template&lt;typename T_type &gt; </td></tr>
<tr class="memitem:ad19937e2850bf14c1fe3ac79109f8870"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad19937e2850bf14c1fe3ac79109f8870">create_method</a> (const std::string &amp;method_name, sigc::slot&lt; T_type &gt; slot)</td></tr>
<tr class="memdesc:ad19937e2850bf14c1fe3ac79109f8870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="classDBus_1_1Object.html#ad19937e2850bf14c1fe3ac79109f8870">More...</a><br /></td></tr>
<tr class="separator:ad19937e2850bf14c1fe3ac79109f8870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b746d0734d6604135eee5b684fc6d1"><td class="memTemplParams" colspan="2">template&lt;typename T_type &gt; </td></tr>
<tr class="memitem:a51b746d0734d6604135eee5b684fc6d1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a51b746d0734d6604135eee5b684fc6d1">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot&lt; T_type &gt; slot)</td></tr>
<tr class="memdesc:a51b746d0734d6604135eee5b684fc6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="classDBus_1_1Object.html#a51b746d0734d6604135eee5b684fc6d1">More...</a><br /></td></tr>
<tr class="separator:a51b746d0734d6604135eee5b684fc6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1decf65a7b082ffcf7c7f9a101ee4b"><td class="memTemplParams" colspan="2">template&lt;typename T_type &gt; </td></tr>
<tr class="memitem:ace1decf65a7b082ffcf7c7f9a101ee4b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Property.html">Property</a>&lt; T_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ace1decf65a7b082ffcf7c7f9a101ee4b">create_property</a> (const std::string &amp;interface_name, const std::string &amp;property_name, <a class="el" href="namespaceDBus.html#a3cec46da5ca876a0ea8ab72ca43a2abc">PropertyAccess</a> access_type=<a class="el" href="namespaceDBus.html#a3cec46da5ca876a0ea8ab72ca43a2abca70a2a84088d405a2e3f1e3accaa16723">PropertyAccess::ReadWrite</a>, <a class="el" href="namespaceDBus.html#aea507c01fe436f3445e41ebc3ee2c0e9">PropertyUpdateType</a> update_type=<a class="el" href="namespaceDBus.html#aea507c01fe436f3445e41ebc3ee2c0e9a9ac41b6a577daadd588f0fcde0071e8b">PropertyUpdateType::Updates</a>)</td></tr>
<tr class="separator:ace1decf65a7b082ffcf7c7f9a101ee4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbcd801c315e2e88a39b6654bceedef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aabbcd801c315e2e88a39b6654bceedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the interface found with the given name.  <a href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">More...</a><br /></td></tr>
<tr class="separator:aabbcd801c315e2e88a39b6654bceedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec6e59d6996734e49cb53e01acfb767"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a9ec6e59d6996734e49cb53e01acfb767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> has a named interface.  <a href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">More...</a><br /></td></tr>
<tr class="separator:a9ec6e59d6996734e49cb53e01acfb767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f94c031faecdffd791154e4e141e821"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a2f94c031faecdffd791154e4e141e821">default_interface</a> () const</td></tr>
<tr class="memdesc:a2f94c031faecdffd791154e4e141e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default interface associated with this object.  <a href="classDBus_1_1Object.html#a2f94c031faecdffd791154e4e141e821">More...</a><br /></td></tr>
<tr class="separator:a2f94c031faecdffd791154e4e141e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723b0433c976e9a7c5277034d3f9cd16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface</a> (const std::string &amp;new_default_name)</td></tr>
<tr class="memdesc:a723b0433c976e9a7c5277034d3f9cd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default interface to a specific name.  <a href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">More...</a><br /></td></tr>
<tr class="separator:a723b0433c976e9a7c5277034d3f9cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d28dcb0f4b1f6e9433321dabd9abca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3d28dcb0f4b1f6e9433321dabd9abca6">set_default_interface</a> (std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; <a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name</a>)</td></tr>
<tr class="memdesc:a3d28dcb0f4b1f6e9433321dabd9abca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default interface for handling calls to no interface.  <a href="classDBus_1_1Object.html#a3d28dcb0f4b1f6e9433321dabd9abca6">More...</a><br /></td></tr>
<tr class="separator:a3d28dcb0f4b1f6e9433321dabd9abca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51bf37df4f3de1747a8bd54a0602596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">remove_default_interface</a> ()</td></tr>
<tr class="memdesc:af51bf37df4f3de1747a8bd54a0602596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the currently set (if any) default interface.  <a href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">More...</a><br /></td></tr>
<tr class="separator:af51bf37df4f3de1747a8bd54a0602596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53efa3eca63444f3462f7855b8805e"><td class="memTemplParams" colspan="2">template&lt;class... T_type&gt; </td></tr>
<tr class="memitem:a3d53efa3eca63444f3462f7855b8805e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Signal.html">Signal</a>&lt; T_type... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3d53efa3eca63444f3462f7855b8805e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and a variable number of parameters and adds it to the default interface.  <a href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e">More...</a><br /></td></tr>
<tr class="separator:a3d53efa3eca63444f3462f7855b8805e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7235829c8ace80f6d9949e11a5ea31c7"><td class="memTemplParams" colspan="2">template&lt;class... T_type&gt; </td></tr>
<tr class="memitem:a7235829c8ace80f6d9949e11a5ea31c7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Signal.html">Signal</a>&lt; T_type... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7235829c8ace80f6d9949e11a5ea31c7">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7235829c8ace80f6d9949e11a5ea31c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and a variable number of parameters and adds it to the named interface.  <a href="classDBus_1_1Object.html#a7235829c8ace80f6d9949e11a5ea31c7">More...</a><br /></td></tr>
<tr class="separator:a7235829c8ace80f6d9949e11a5ea31c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41849a351a01d2a48bf3f9ee1741f811"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001">Children</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a41849a351a01d2a48bf3f9ee1741f811">children</a> () const</td></tr>
<tr class="memdesc:a41849a351a01d2a48bf3f9ee1741f811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the children associated with this object instance.  <a href="classDBus_1_1Object.html#a41849a351a01d2a48bf3f9ee1741f811">More...</a><br /></td></tr>
<tr class="separator:a41849a351a01d2a48bf3f9ee1741f811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b203e0a98bc3ceee20f693d22d2b90"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a50b203e0a98bc3ceee20f693d22d2b90">child</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a50b203e0a98bc3ceee20f693d22d2b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a named child of this object.  <a href="classDBus_1_1Object.html#a50b203e0a98bc3ceee20f693d22d2b90">More...</a><br /></td></tr>
<tr class="separator:a50b203e0a98bc3ceee20f693d22d2b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac9565d39e5216de0b557ea5e6a9534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aeac9565d39e5216de0b557ea5e6a9534">add_child</a> (const std::string &amp;name, std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt; <a class="el" href="classDBus_1_1Object.html#a50b203e0a98bc3ceee20f693d22d2b90">child</a>, bool force=false)</td></tr>
<tr class="memdesc:aeac9565d39e5216de0b557ea5e6a9534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set.  <a href="classDBus_1_1Object.html#aeac9565d39e5216de0b557ea5e6a9534">More...</a><br /></td></tr>
<tr class="separator:aeac9565d39e5216de0b557ea5e6a9534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3515d2b48bd3f14aba2a06d77572d4cb">remove_child</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the named child from this object.  <a href="classDBus_1_1Object.html#a3515d2b48bd3f14aba2a06d77572d4cb">More...</a><br /></td></tr>
<tr class="separator:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d045e64a7cba7e2fb6877385579bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">has_child</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a66d045e64a7cba7e2fb6877385579bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an object has a child with a specified name.  <a href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">More...</a><br /></td></tr>
<tr class="separator:a66d045e64a7cba7e2fb6877385579bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a90a8ee8c991257ac19c56ca315893"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect</a> (int space_depth=0) const</td></tr>
<tr class="memdesc:a40a90a8ee8c991257ac19c56ca315893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a> XML description of this interface.  <a href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">More...</a><br /></td></tr>
<tr class="separator:a40a90a8ee8c991257ac19c56ca315893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e382cbebd5962ba371eee42672f4be"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ab1e382cbebd5962ba371eee42672f4be">signal_interface_added</a> ()</td></tr>
<tr class="memdesc:ab1e382cbebd5962ba371eee42672f4be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when an interface is added to this object.  <a href="classDBus_1_1Object.html#ab1e382cbebd5962ba371eee42672f4be">More...</a><br /></td></tr>
<tr class="separator:ab1e382cbebd5962ba371eee42672f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908167ac41d10077b68795c43afdc60c"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a908167ac41d10077b68795c43afdc60c">signal_interface_removed</a> ()</td></tr>
<tr class="memdesc:a908167ac41d10077b68795c43afdc60c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when an interface is removed from this object.  <a href="classDBus_1_1Object.html#a908167ac41d10077b68795c43afdc60c">More...</a><br /></td></tr>
<tr class="separator:a908167ac41d10077b68795c43afdc60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4d45a59ed2d15b5e840256549c67fa"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;, std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aed4d45a59ed2d15b5e840256549c67fa">signal_default_interface_changed</a> ()</td></tr>
<tr class="memdesc:aed4d45a59ed2d15b5e840256549c67fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when the default interface of this object is changed.  <a href="classDBus_1_1Object.html#aed4d45a59ed2d15b5e840256549c67fa">More...</a><br /></td></tr>
<tr class="separator:aed4d45a59ed2d15b5e840256549c67fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a279e0c0b3034670f341f9811b08eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0a279e0c0b3034670f341f9811b08eb7">handle_message</a> (std::shared_ptr&lt; const <a class="el" href="classDBus_1_1Message.html">Message</a> &gt; msg)</td></tr>
<tr class="memdesc:a0a279e0c0b3034670f341f9811b08eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the specified message on the specified connection.  <a href="classDBus_1_1Object.html#a0a279e0c0b3034670f341f9811b08eb7">More...</a><br /></td></tr>
<tr class="separator:a0a279e0c0b3034670f341f9811b08eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a026c8bb0d0a9ca01ab0b69796efd8d39"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a026c8bb0d0a9ca01ab0b69796efd8d39">create</a> (const std::string &amp;<a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path</a>=std::string())</td></tr>
<tr class="memdesc:a026c8bb0d0a9ca01ab0b69796efd8d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> that will register as a primary or fallback handler.  <a href="classDBus_1_1Object.html#a026c8bb0d0a9ca01ab0b69796efd8d39">More...</a><br /></td></tr>
<tr class="separator:a026c8bb0d0a9ca01ab0b69796efd8d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a488bfc0ecd602069ee7af0da4e463f91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a488bfc0ecd602069ee7af0da4e463f91">Object</a> (const std::string &amp;<a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path</a>)</td></tr>
<tr class="memdesc:a488bfc0ecd602069ee7af0da4e463f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class has a protected constructor.  <a href="classDBus_1_1Object.html#a488bfc0ecd602069ee7af0da4e463f91">More...</a><br /></td></tr>
<tr class="separator:a488bfc0ecd602069ee7af0da4e463f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a762c72db7c32256c3799efa2c9aa3259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a762c72db7c32256c3799efa2c9aa3259">DBUS_CXX_PROPAGATE_CONST</a> (std::unique_ptr&lt; priv_data &gt;) m_priv</td></tr>
<tr class="separator:a762c72db7c32256c3799efa2c9aa3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> represents a local object that is able to be called over the <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a>. </p>
<p>Interfaces, methods, and signals can be created from this <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a>.</p>
<p>Note: Because the header 'INTERFACE' is <b>not required</b> for method calls, use the method <code>set_default_interface</code> to set an interface that will handle method calls without 'INTERFACE' set. If a message is received without the 'INTERFACE' set, the following is used to determine how to handle the message:</p><ul>
<li>If the default interface is not set, return an error <code>org.freedesktop.DBus.Error.UnknownInterface</code> </li>
<li>If the default interface is set, use that interface to try and handle the message. The normal message handling rules apply at this point, e.g. if the method does not exist an error <code>org.freedesktop.DBus.Error.UnknownMethod</code> will be returned.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Rick L Vinyard Jr <a href="#" onclick="location.href='mai'+'lto:'+'rvi'+'ny'+'ard'+'@c'+'s.n'+'ms'+'u.e'+'du'; return false;">rviny<span style="display: none;">.nosp@m.</span>ard@<span style="display: none;">.nosp@m.</span>cs.nm<span style="display: none;">.nosp@m.</span>su.e<span style="display: none;">.nosp@m.</span>du</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="callee_object_inherited_8cpp-example.html#_a0">callee_object_inherited.cpp</a>, and <a class="el" href="signal_emitter_object_8cpp-example.html#_a0">signal_emitter_object.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a69552bbf95f68bc043314035bd3d5001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69552bbf95f68bc043314035bd3d5001">&#9670;&nbsp;</a></span>Children</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classDBus_1_1Object.html">Object</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001">DBus::Object::Children</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a></code> instance's children. </p>
<p>The <em>key</em> is the child's name and the <em>value</em> </p>
<p><b>Data</b> <b>Structure</b> - map: an object's children must be uniquely named <b>Key</b> - child name <b>Value</b> -smart pointer to a child object.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001" title="Typedef to storage structure for an Object instance&#39;s children.">Object::Children</a></code> </p>

</div>
</div>
<a id="a9e663be287217ecddb85029b88903193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e663be287217ecddb85029b88903193">&#9670;&nbsp;</a></span>Interfaces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193">DBus::Object::Interfaces</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a></code> instance's interfaces. </p>
<p><b>Key</b> - interface name <b>Value</b> -smart pointer to an interface.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193" title="Typedef to the storage structure for an Object instance&#39;s interfaces.">Object::Interfaces</a></code> </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a488bfc0ecd602069ee7af0da4e463f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488bfc0ecd602069ee7af0da4e463f91">&#9670;&nbsp;</a></span>Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class has a protected constructor. </p>
<p>Use the <code><a class="el" href="classDBus_1_1Object.html#a026c8bb0d0a9ca01ab0b69796efd8d39" title="Creates a named Object that will register as a primary or fallback handler.">create()</a></code> methods to obtain a smart pointer to a new instance. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a026c8bb0d0a9ca01ab0b69796efd8d39">create()</a>.</p>

</div>
</div>
<a id="a22eb06f7f4cbed84f434d8a26b56dded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eb06f7f4cbed84f434d8a26b56dded">&#9670;&nbsp;</a></span>~Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::~Object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeac9565d39e5216de0b557ea5e6a9534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac9565d39e5216de0b557ea5e6a9534">&#9670;&nbsp;</a></span>add_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the child was successfully added, <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to use for the child. </td></tr>
    <tr><td class="paramname">child</td><td>A smart pointer to an object to add as a child. </td></tr>
    <tr><td class="paramname">force</td><td>If <code>true</code> a child with the same name will be replaced. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a50b203e0a98bc3ceee20f693d22d2b90">child()</a>, <a class="el" href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">connection()</a>, and <a class="el" href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">has_child()</a>.</p>

</div>
</div>
<a id="a772bd922bdd031f7745658429c34ff4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772bd922bdd031f7745658429c34ff4f">&#9670;&nbsp;</a></span>add_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_interface </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td>
          <td class="paramname"><em>interface_by_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the interface to this object. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">connection()</a>, <a class="el" href="object_8cpp.html#aa804a796c19a504cc8f60912b8e84a5b">LOGGER_NAME</a>, <a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path()</a>, and <a class="el" href="simplelogger_8h.html#ad0215b92ad8365f26bba18cb99ce6f9d">SIMPLELOGGER_DEBUG</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>.</p>

</div>
</div>
<a id="a50b203e0a98bc3ceee20f693d22d2b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b203e0a98bc3ceee20f693d22d2b90">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt; DBus::Object::child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a named child of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to a child with the specified name, or a null smart pointer if no child found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to return </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#aeac9565d39e5216de0b557ea5e6a9534">add_child()</a>.</p>

</div>
</div>
<a id="a41849a351a01d2a48bf3f9ee1741f811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41849a351a01d2a48bf3f9ee1741f811">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a69552bbf95f68bc043314035bd3d5001">Object::Children</a> &amp; DBus::Object::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the children associated with this object instance. </p>

</div>
</div>
<a id="ae45ff214b1e5681fd4272b050d3b02c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45ff214b1e5681fd4272b050d3b02c8">&#9670;&nbsp;</a></span>connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; DBus::Object::connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connection this handler is registered with. </p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#aeac9565d39e5216de0b557ea5e6a9534">add_child()</a>, <a class="el" href="classDBus_1_1Object.html#a772bd922bdd031f7745658429c34ff4f">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a0a279e0c0b3034670f341f9811b08eb7">handle_message()</a>, and <a class="el" href="classDBus_1_1Object.html#a91ec64de5d749247e31d3721747a02f5">unregister()</a>.</p>

</div>
</div>
<a id="a026c8bb0d0a9ca01ab0b69796efd8d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026c8bb0d0a9ca01ab0b69796efd8d39">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt; DBus::Object::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a named <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> that will register as a primary or fallback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path the object will handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="callee_object_inherited_8cpp-example.html#a1">callee_object_inherited.cpp</a>, and <a class="el" href="signal_emitter_object_8cpp-example.html#a2">signal_emitter_object.cpp</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a488bfc0ecd602069ee7af0da4e463f91">Object()</a>, and <a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Connection.html#a2894b667c099a711d3ed0807ebf07881">DBus::Connection::create_object()</a>.</p>

</div>
</div>
<a id="a14192b7048cf58735b2ded8e83718f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14192b7048cf58735b2ded8e83718f17">&#9670;&nbsp;</a></span>create_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; DBus::Object::create_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and adds the named interface to this object. </p>
<p>If the string is empty, and there is no default interface set, this will set the default interface.</p>
<dl class="section return"><dt>Returns</dt><dd>the newly created interface </dd></dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a772bd922bdd031f7745658429c34ff4f">add_interface()</a>, <a class="el" href="classDBus_1_1Interface.html#af7e45750090935c2357c9582dc8e0d83">DBus::Interface::create()</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#ad19937e2850bf14c1fe3ac79109f8870">create_method()</a>, <a class="el" href="classDBus_1_1Object.html#ace1decf65a7b082ffcf7c7f9a101ee4b">create_property()</a>, and <a class="el" href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e">create_signal()</a>.</p>

</div>
</div>
<a id="a51b746d0734d6604135eee5b684fc6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b746d0734d6604135eee5b684fc6d1">&#9670;&nbsp;</a></span>create_method() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDBus_1_1Method.html">Method</a>&lt;T_type&gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot&lt; T_type &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name()</a>.</p>

</div>
</div>
<a id="ad19937e2850bf14c1fe3ac79109f8870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19937e2850bf14c1fe3ac79109f8870">&#9670;&nbsp;</a></span>create_method() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDBus_1_1Method.html">Method</a>&lt;T_type&gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot&lt; T_type &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a2f94c031faecdffd791154e4e141e821">default_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="ace1decf65a7b082ffcf7c7f9a101ee4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1decf65a7b082ffcf7c7f9a101ee4b">&#9670;&nbsp;</a></span>create_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDBus_1_1Property.html">Property</a>&lt;T_type&gt; &gt; DBus::Object::create_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#a3cec46da5ca876a0ea8ab72ca43a2abc">PropertyAccess</a>&#160;</td>
          <td class="paramname"><em>access_type</em> = <code><a class="el" href="namespaceDBus.html#a3cec46da5ca876a0ea8ab72ca43a2abca70a2a84088d405a2e3f1e3accaa16723">PropertyAccess::ReadWrite</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#aea507c01fe436f3445e41ebc3ee2c0e9">PropertyUpdateType</a>&#160;</td>
          <td class="paramname"><em>update_type</em> = <code><a class="el" href="namespaceDBus.html#aea507c01fe436f3445e41ebc3ee2c0e9a9ac41b6a577daadd588f0fcde0071e8b">PropertyUpdateType::Updates</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name()</a>.</p>

</div>
</div>
<a id="a7235829c8ace80f6d9949e11a5ea31c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7235829c8ace80f6d9949e11a5ea31c7">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDBus_1_1Signal.html">Signal</a>&lt;T_type...&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and a variable number of parameters and adds it to the named interface. </p>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e" title="Creates a signal with a return value (possibly void ) and a variable number of parameters and adds it...">create_signal()</a></code> call will determine the signature of the signal created.</p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal </dd></dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#aa77f36549d94e97943656238b6998c3b">interface_by_name()</a>.</p>

</div>
</div>
<a id="a3d53efa3eca63444f3462f7855b8805e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d53efa3eca63444f3462f7855b8805e">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDBus_1_1Signal.html">Signal</a>&lt;T_type...&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and a variable number of parameters and adds it to the default interface. </p>
<p><b>Note</b>: This will create a default interface if it does not already exist.</p>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e" title="Creates a signal with a return value (possibly void ) and a variable number of parameters and adds it...">create_signal()</a></code> call will determine the signature of the signal created.</p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal </dd></dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a2f94c031faecdffd791154e4e141e821">default_interface()</a>.</p>

</div>
</div>
<a id="a762c72db7c32256c3799efa2c9aa3259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c72db7c32256c3799efa2c9aa3259">&#9670;&nbsp;</a></span>DBUS_CXX_PROPAGATE_CONST()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::DBUS_CXX_PROPAGATE_CONST </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; priv_data &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f94c031faecdffd791154e4e141e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f94c031faecdffd791154e4e141e821">&#9670;&nbsp;</a></span>default_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; DBus::Object::default_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default interface associated with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>The default interface, or a null smart pointer if no default is set </dd></dl>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#ad19937e2850bf14c1fe3ac79109f8870">create_method()</a>, and <a class="el" href="classDBus_1_1Object.html#a3d53efa3eca63444f3462f7855b8805e">create_signal()</a>.</p>

</div>
</div>
<a id="a0a279e0c0b3034670f341f9811b08eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a279e0c0b3034670f341f9811b08eb7">&#9670;&nbsp;</a></span>handle_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a> DBus::Object::handle_message </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classDBus_1_1Message.html">Message</a> &gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the specified message on the specified connection. </p>
<p>If <code>msg</code> is an introspection message, the object will rely on its <code>introspection()</code> method to provide a reply.</p>
<p>Looks for interfaces specified in the message first. If the message does not specify an interface or the specified interface is not found the default interface will be used.</p>
<p>If the specified interface is found, all matching interfaces will be tried until an interface handler returns <code>HandlerResult::HANDLED</code>. Once an interface returns <code>HandlerResult::HANDLED</code> no further interfaces will be tried.</p>
<p>If no interface returns <code>HandlerResult::HANDLED</code> the default interface (if one is set) will be tried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>HandlerResult::HANDLED</code> if this object handled the message, <code>HandlerResult::NOT_HANDLED</code> otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The <a class="el" href="classDBus_1_1Connection.html" title="Connection point to the DBus.">Connection</a> to send the reply message on </td></tr>
    <tr><td class="paramname">msg</td><td>The message to handle; must be a <a class="el" href="classDBus_1_1CallMessage.html" title="Represents a DBus call message.">CallMessage</a> or it will not be handled </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceDBus.html#a6b5b447b57489b4106d096545e528510aca3547acb9162b49fb4a6594ed9b3030">DBus::CALL</a>, <a class="el" href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">connection()</a>, <a class="el" href="utility_8h.html#a52e0100c1343c07557166c73a2a11661">DBUS_CXX_INTROSPECTABLE_INTERFACE</a>, <a class="el" href="utility_8h.html#ab86bd957dc0483d18b0e232d47c6210d">DBUS_CXX_PEER_INTERFACE</a>, <a class="el" href="utility_8h.html#acb27b72af4ac74616c36176052dfa45f">DBUS_CXX_PROPERTIES_INTERFACE</a>, <a class="el" href="dbus-error_8h.html#a31bfe644f787846077e11da030f61379">DBUSCXX_ERROR_IO_ERROR</a>, <a class="el" href="connection_8h.html#a5d3723692bb286a70f934310afc47e7a">DBUSCXX_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE</a>, <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0a827211270de454ea3e0df8f57995efed">DBus::Handled</a>, <a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect()</a>, <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0abafbfd56a62cd06db930ffe9e05f2441">DBus::Invalid_Interface</a>, <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0a7a246b11a5df9912f0686ca6fd8abdcf">DBus::Invalid_Method</a>, <a class="el" href="object_8cpp.html#aa804a796c19a504cc8f60912b8e84a5b">LOGGER_NAME</a>, <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0a135689c2c8751cd2b8316f37ff1958e5">DBus::Not_Handled</a>, <a class="el" href="simplelogger_8h.html#ad0215b92ad8365f26bba18cb99ce6f9d">SIMPLELOGGER_DEBUG</a>, and <a class="el" href="simplelogger_8h.html#a2f8e2c7dabbfe7e8398f6da53f411375">SIMPLELOGGER_ERROR</a>.</p>

</div>
</div>
<a id="a66d045e64a7cba7e2fb6877385579bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d045e64a7cba7e2fb6877385579bf4">&#9670;&nbsp;</a></span>has_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether an object has a child with a specified name. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the object has the named child, <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#aeac9565d39e5216de0b557ea5e6a9534">add_child()</a>.</p>

</div>
</div>
<a id="a9ec6e59d6996734e49cb53e01acfb767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec6e59d6996734e49cb53e01acfb767">&#9670;&nbsp;</a></span>has_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether an <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> has a named interface. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the object has the named interface, <code>false</code> otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the interface to look for </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a7235829c8ace80f6d9949e11a5ea31c7">create_signal()</a>.</p>

</div>
</div>
<a id="aa77f36549d94e97943656238b6998c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77f36549d94e97943656238b6998c3b">&#9670;&nbsp;</a></span>interface_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; DBus::Object::interface_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interface with the given name. </p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a51b746d0734d6604135eee5b684fc6d1">create_method()</a>, <a class="el" href="classDBus_1_1Object.html#ace1decf65a7b082ffcf7c7f9a101ee4b">create_property()</a>, and <a class="el" href="classDBus_1_1Object.html#a7235829c8ace80f6d9949e11a5ea31c7">create_signal()</a>.</p>

</div>
</div>
<a id="a4e4359771c176e0bb0b38988c7616ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4359771c176e0bb0b38988c7616ca8">&#9670;&nbsp;</a></span>interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a9e663be287217ecddb85029b88903193">Object::Interfaces</a> &amp; DBus::Object::interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html" title="An Object represents a local object that is able to be called over the DBus.">Object</a> instance. </p>

</div>
</div>
<a id="a40a90a8ee8c991257ac19c56ca315893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a90a8ee8c991257ac19c56ca315893">&#9670;&nbsp;</a></span>introspect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DBus::Object::introspect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>space_depth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespaceDBus.html" title="Global DBus namespace, where everything happens.">DBus</a> XML description of this interface. </p>

<p class="reference">References <a class="el" href="utility_8h.html#a52e0100c1343c07557166c73a2a11661">DBUS_CXX_INTROSPECTABLE_INTERFACE</a>, <a class="el" href="utility_8h.html#ab86bd957dc0483d18b0e232d47c6210d">DBUS_CXX_PEER_INTERFACE</a>, <a class="el" href="utility_8h.html#acb27b72af4ac74616c36176052dfa45f">DBUS_CXX_PROPERTIES_INTERFACE</a>, and <a class="el" href="classDBus_1_1Object.html#a1ba3d2f5de59cade1c5ed13a85f7571c">path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a0a279e0c0b3034670f341f9811b08eb7">handle_message()</a>.</p>

</div>
</div>
<a id="a1ba3d2f5de59cade1c5ed13a85f7571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba3d2f5de59cade1c5ed13a85f7571c">&#9670;&nbsp;</a></span>path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Path.html">Path</a> &amp; DBus::Object::path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the path this handler is associated with. </p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a772bd922bdd031f7745658429c34ff4f">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a026c8bb0d0a9ca01ab0b69796efd8d39">create()</a>, <a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect()</a>, and <a class="el" href="classDBus_1_1Object.html#a488bfc0ecd602069ee7af0da4e463f91">Object()</a>.</p>

</div>
</div>
<a id="a3515d2b48bd3f14aba2a06d77572d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3515d2b48bd3f14aba2a06d77572d4cb">&#9670;&nbsp;</a></span>remove_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::remove_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the named child from this object. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the child was found and removed, <code>false</code> if no child by the name was found to remove. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af51bf37df4f3de1747a8bd54a0602596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51bf37df4f3de1747a8bd54a0602596">&#9670;&nbsp;</a></span>remove_default_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_default_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the currently set (if any) default interface. </p>
<p>There wil not be a default interface set. </p>

</div>
</div>
<a id="aabbcd801c315e2e88a39b6654bceedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbcd801c315e2e88a39b6654bceedef">&#9670;&nbsp;</a></span>remove_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the interface found with the given name. </p>
<p>This will not remove the default interface if the name matches - use remove_default_interface instead </p>

</div>
</div>
<a id="aa84d5b62de8ad526e19c8af7c442b72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84d5b62de8ad526e19c8af7c442b72d">&#9670;&nbsp;</a></span>set_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::set_connection </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the connection that this object is on. </p>
<p>Generally, you should not call this, as calling <a class="el" href="classDBus_1_1Connection.html#a8a17cb77b25bd5c4ecf93b7e755db4d7" title="Register an object with this connection.">Connection::register_object</a> will do this for you automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="object_8cpp.html#aa804a796c19a504cc8f60912b8e84a5b">LOGGER_NAME</a>, <a class="el" href="simplelogger_8h.html#ad0215b92ad8365f26bba18cb99ce6f9d">SIMPLELOGGER_DEBUG</a>, and <a class="el" href="classDBus_1_1Object.html#a91ec64de5d749247e31d3721747a02f5">unregister()</a>.</p>

</div>
</div>
<a id="a723b0433c976e9a7c5277034d3f9cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723b0433c976e9a7c5277034d3f9cd16">&#9670;&nbsp;</a></span>set_default_interface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::set_default_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_default_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default interface to a specific name. </p>
<p>The currently-existing interface with the given name is used. If an interface with the given name is not found, the default interface will not be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_default_name</td><td>The name of the interface to use as the default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if an interface with the specified name was found, <code>false</code> otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a14192b7048cf58735b2ded8e83718f17">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#ad19937e2850bf14c1fe3ac79109f8870">create_method()</a>.</p>

</div>
</div>
<a id="a3d28dcb0f4b1f6e9433321dabd9abca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d28dcb0f4b1f6e9433321dabd9abca6">&#9670;&nbsp;</a></span>set_default_interface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::set_default_interface </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td>
          <td class="paramname"><em>interface_by_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default interface for handling calls to no interface. </p>
<p>If the shared pointer is invalid, this function returns false and does nothing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>True if the default interface was updated, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed4d45a59ed2d15b5e840256549c67fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4d45a59ed2d15b5e840256549c67fa">&#9670;&nbsp;</a></span>signal_default_interface_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;, std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;)&gt; DBus::Object::signal_default_interface_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when the default interface of this object is changed. </p>
<p>The first parameter of the callback is a pointer to the old default interface, and the second parameter is a callback to the new default interface. </p>

</div>
</div>
<a id="ab1e382cbebd5962ba371eee42672f4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e382cbebd5962ba371eee42672f4be">&#9670;&nbsp;</a></span>signal_interface_added()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;) &gt; DBus::Object::signal_interface_added </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when an interface is added to this object. </p>
<p>The first parameter of the callback is a pointer to the newly added interface. </p>

</div>
</div>
<a id="a908167ac41d10077b68795c43afdc60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908167ac41d10077b68795c43afdc60c">&#9670;&nbsp;</a></span>signal_interface_removed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;)&gt; DBus::Object::signal_interface_removed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classDBus_1_1Signal.html">Signal</a> emitted when an interface is removed from this object. </p>
<p>The first parameter of the callback is a pointer to the removed interface. </p>

</div>
</div>
<a id="a7c21d2278f15401bbb11b0058ea0848f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c21d2278f15401bbb11b0058ea0848f">&#9670;&nbsp;</a></span>signal_registered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;)&gt; &amp; DBus::Object::signal_registered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emitted when this object is registered with a connection. </p>

</div>
</div>
<a id="ac6966d3202df526077529066c1169540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6966d3202df526077529066c1169540">&#9670;&nbsp;</a></span>signal_unregistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void(std::shared_ptr&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;)&gt; &amp; DBus::Object::signal_unregistered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emitted when this object is unregistered from a connection. </p>

</div>
</div>
<a id="a91ec64de5d749247e31d3721747a02f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ec64de5d749247e31d3721747a02f5">&#9670;&nbsp;</a></span>unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::unregister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters the handler. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ae45ff214b1e5681fd4272b050d3b02c8">connection()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#aa84d5b62de8ad526e19c8af7c442b72d">set_connection()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="object_8h_source.html">object.h</a></li>
<li><a class="el" href="object_8cpp.html">object.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 7 2023 15:36:56 for dbus-cxx by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
