<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DBus::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link REL="SHORTCUT ICON" HREF="favicon.ico">
</head><body>
<center><a href="https://dbus-cxx.github.io"><img src="dbus-cxx-logo-med.png" alt="dbus-cxx logo" border="0"/></a></center>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDBus.html">DBus</a></li><li class="navelem"><a class="el" href="classDBus_1_1Object.html">Object</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDBus_1_1Object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DBus::Object Class Reference<div class="ingroups"><a class="el" href="group__local.html">Local Objects</a> &#124; <a class="el" href="group__objects.html">Objects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="object_8h_source.html">object.h</a>&gt;</code></p>

<p>Inherits DBus::ObjectPathHandler.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5bf674b9935ccede5a0cc5c9e5edfbc4"><td class="memItemLeft" align="right" valign="top">typedef DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">pointer</a></td></tr>
<tr class="memdesc:a5bf674b9935ccede5a0cc5c9e5edfbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to smart pointers to <a class="el" href="classDBus_1_1Object.html">Object</a>.  <a href="#a5bf674b9935ccede5a0cc5c9e5edfbc4">More...</a><br /></td></tr>
<tr class="separator:a5bf674b9935ccede5a0cc5c9e5edfbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd597323a47e73d511c8d55e271fb83"><td class="memItemLeft" align="right" valign="top">typedef std::multimap&lt; std::string, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a></td></tr>
<tr class="memdesc:a3dd597323a47e73d511c8d55e271fb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's interfaces.  <a href="#a3dd597323a47e73d511c8d55e271fb83">More...</a><br /></td></tr>
<tr class="separator:a3dd597323a47e73d511c8d55e271fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deca17387532da99bdc7f1f23812046"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a></td></tr>
<tr class="memdesc:a3deca17387532da99bdc7f1f23812046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's children.  <a href="#a3deca17387532da99bdc7f1f23812046">More...</a><br /></td></tr>
<tr class="separator:a3deca17387532da99bdc7f1f23812046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22eb06f7f4cbed84f434d8a26b56dded"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a22eb06f7f4cbed84f434d8a26b56dded">~Object</a> ()</td></tr>
<tr class="separator:a22eb06f7f4cbed84f434d8a26b56dded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de7bda76136ba0ee003dc2a34446e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac2de7bda76136ba0ee003dc2a34446e7">register_with_connection</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; conn)</td></tr>
<tr class="memdesc:ac2de7bda76136ba0ee003dc2a34446e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends base version to include registering signals.  <a href="#ac2de7bda76136ba0ee003dc2a34446e7">More...</a><br /></td></tr>
<tr class="separator:ac2de7bda76136ba0ee003dc2a34446e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4359771c176e0bb0b38988c7616ca8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a4e4359771c176e0bb0b38988c7616ca8">interfaces</a> () const</td></tr>
<tr class="memdesc:a4e4359771c176e0bb0b38988c7616ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html">Object</a> instance.  <a href="#a4e4359771c176e0bb0b38988c7616ca8">More...</a><br /></td></tr>
<tr class="separator:a4e4359771c176e0bb0b38988c7616ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c348a2a12608d9a15db01e4b652e132"><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a6c348a2a12608d9a15db01e4b652e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first interface with the given name.  <a href="#a6c348a2a12608d9a15db01e4b652e132">More...</a><br /></td></tr>
<tr class="separator:a6c348a2a12608d9a15db01e4b652e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34967617b0b59cfb8f861ec2dab7ad2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface</a>)</td></tr>
<tr class="memdesc:a34967617b0b59cfb8f861ec2dab7ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the interface to this object.  <a href="#a34967617b0b59cfb8f861ec2dab7ad2e">More...</a><br /></td></tr>
<tr class="separator:a34967617b0b59cfb8f861ec2dab7ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76111752ea7a0d59549a9d95be03bd69"><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a76111752ea7a0d59549a9d95be03bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds the named interface to this object.  <a href="#a76111752ea7a0d59549a9d95be03bd69">More...</a><br /></td></tr>
<tr class="separator:a76111752ea7a0d59549a9d95be03bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652697db4c23d9afffeb7e94608258f6"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:a652697db4c23d9afffeb7e94608258f6"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a652697db4c23d9afffeb7e94608258f6">create_method</a> (const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)</td></tr>
<tr class="memdesc:a652697db4c23d9afffeb7e94608258f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a652697db4c23d9afffeb7e94608258f6">More...</a><br /></td></tr>
<tr class="separator:a652697db4c23d9afffeb7e94608258f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80235f6723372fb3d54763a54f8c723"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr class="memitem:ac80235f6723372fb3d54763a54f8c723"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac80235f6723372fb3d54763a54f8c723">create_method</a> (const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)</td></tr>
<tr class="memdesc:ac80235f6723372fb3d54763a54f8c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ac80235f6723372fb3d54763a54f8c723">More...</a><br /></td></tr>
<tr class="separator:ac80235f6723372fb3d54763a54f8c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505de25301f877951c1cec0665afbf7d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a505de25301f877951c1cec0665afbf7d"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a505de25301f877951c1cec0665afbf7d">create_method</a> (const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)</td></tr>
<tr class="memdesc:a505de25301f877951c1cec0665afbf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a505de25301f877951c1cec0665afbf7d">More...</a><br /></td></tr>
<tr class="separator:a505de25301f877951c1cec0665afbf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b07f1189b697116c2ef385aa88317"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:a9a4b07f1189b697116c2ef385aa88317"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9a4b07f1189b697116c2ef385aa88317">create_method</a> (const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)</td></tr>
<tr class="memdesc:a9a4b07f1189b697116c2ef385aa88317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a9a4b07f1189b697116c2ef385aa88317">More...</a><br /></td></tr>
<tr class="separator:a9a4b07f1189b697116c2ef385aa88317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb8d86968cb7e329e8e6e85dc333aaa"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:a7eb8d86968cb7e329e8e6e85dc333aaa"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7eb8d86968cb7e329e8e6e85dc333aaa">create_method</a> (const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)</td></tr>
<tr class="memdesc:a7eb8d86968cb7e329e8e6e85dc333aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a7eb8d86968cb7e329e8e6e85dc333aaa">More...</a><br /></td></tr>
<tr class="separator:a7eb8d86968cb7e329e8e6e85dc333aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503d26fd444c811e7592ef9fbea35831"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:a503d26fd444c811e7592ef9fbea35831"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a503d26fd444c811e7592ef9fbea35831">create_method</a> (const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)</td></tr>
<tr class="memdesc:a503d26fd444c811e7592ef9fbea35831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a503d26fd444c811e7592ef9fbea35831">More...</a><br /></td></tr>
<tr class="separator:a503d26fd444c811e7592ef9fbea35831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdddd4b9a052dc94281f29f12a299aae"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:afdddd4b9a052dc94281f29f12a299aae"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#afdddd4b9a052dc94281f29f12a299aae">create_method</a> (const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)</td></tr>
<tr class="memdesc:afdddd4b9a052dc94281f29f12a299aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#afdddd4b9a052dc94281f29f12a299aae">More...</a><br /></td></tr>
<tr class="separator:afdddd4b9a052dc94281f29f12a299aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6c691004d71f8cb1091aacd9d12b6"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:a54c6c691004d71f8cb1091aacd9d12b6"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a54c6c691004d71f8cb1091aacd9d12b6">create_method</a> (const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)</td></tr>
<tr class="memdesc:a54c6c691004d71f8cb1091aacd9d12b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a54c6c691004d71f8cb1091aacd9d12b6">More...</a><br /></td></tr>
<tr class="separator:a54c6c691004d71f8cb1091aacd9d12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2455129cef407ce2a57dc687996607c"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:ac2455129cef407ce2a57dc687996607c"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac2455129cef407ce2a57dc687996607c">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)</td></tr>
<tr class="memdesc:ac2455129cef407ce2a57dc687996607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ac2455129cef407ce2a57dc687996607c">More...</a><br /></td></tr>
<tr class="separator:ac2455129cef407ce2a57dc687996607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5237cdc1aa298e4742b2c886e089d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr class="memitem:a68b5237cdc1aa298e4742b2c886e089d"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a68b5237cdc1aa298e4742b2c886e089d">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)</td></tr>
<tr class="memdesc:a68b5237cdc1aa298e4742b2c886e089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a68b5237cdc1aa298e4742b2c886e089d">More...</a><br /></td></tr>
<tr class="separator:a68b5237cdc1aa298e4742b2c886e089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93759dd3f7ec9c01a7d8e5ea1342858"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ac93759dd3f7ec9c01a7d8e5ea1342858"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac93759dd3f7ec9c01a7d8e5ea1342858">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)</td></tr>
<tr class="memdesc:ac93759dd3f7ec9c01a7d8e5ea1342858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ac93759dd3f7ec9c01a7d8e5ea1342858">More...</a><br /></td></tr>
<tr class="separator:ac93759dd3f7ec9c01a7d8e5ea1342858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5158816dc5f27782dc5ec7a1ec5baced"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:a5158816dc5f27782dc5ec7a1ec5baced"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5158816dc5f27782dc5ec7a1ec5baced">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)</td></tr>
<tr class="memdesc:a5158816dc5f27782dc5ec7a1ec5baced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a5158816dc5f27782dc5ec7a1ec5baced">More...</a><br /></td></tr>
<tr class="separator:a5158816dc5f27782dc5ec7a1ec5baced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5879c601f0402ad02a0be4b78ba46734"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:a5879c601f0402ad02a0be4b78ba46734"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5879c601f0402ad02a0be4b78ba46734">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)</td></tr>
<tr class="memdesc:a5879c601f0402ad02a0be4b78ba46734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a5879c601f0402ad02a0be4b78ba46734">More...</a><br /></td></tr>
<tr class="separator:a5879c601f0402ad02a0be4b78ba46734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0381d96cf4e182ca91c5fd85f9935c1"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ac0381d96cf4e182ca91c5fd85f9935c1"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac0381d96cf4e182ca91c5fd85f9935c1">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)</td></tr>
<tr class="memdesc:ac0381d96cf4e182ca91c5fd85f9935c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ac0381d96cf4e182ca91c5fd85f9935c1">More...</a><br /></td></tr>
<tr class="separator:ac0381d96cf4e182ca91c5fd85f9935c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f300c3cff03cfa29c200a70ae45a51"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:a69f300c3cff03cfa29c200a70ae45a51"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a69f300c3cff03cfa29c200a70ae45a51">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)</td></tr>
<tr class="memdesc:a69f300c3cff03cfa29c200a70ae45a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a69f300c3cff03cfa29c200a70ae45a51">More...</a><br /></td></tr>
<tr class="separator:a69f300c3cff03cfa29c200a70ae45a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a8e16941666dca415a63dcf9a95f65"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:a78a8e16941666dca415a63dcf9a95f65"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a78a8e16941666dca415a63dcf9a95f65">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)</td></tr>
<tr class="memdesc:a78a8e16941666dca415a63dcf9a95f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a78a8e16941666dca415a63dcf9a95f65">More...</a><br /></td></tr>
<tr class="separator:a78a8e16941666dca415a63dcf9a95f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbcd801c315e2e88a39b6654bceedef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aabbcd801c315e2e88a39b6654bceedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first interface found with the given name.  <a href="#aabbcd801c315e2e88a39b6654bceedef">More...</a><br /></td></tr>
<tr class="separator:aabbcd801c315e2e88a39b6654bceedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec6e59d6996734e49cb53e01acfb767"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a9ec6e59d6996734e49cb53e01acfb767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an <a class="el" href="classDBus_1_1Object.html">Object</a> has a named interface.  <a href="#a9ec6e59d6996734e49cb53e01acfb767">More...</a><br /></td></tr>
<tr class="separator:a9ec6e59d6996734e49cb53e01acfb767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce43974707a1894bb523f5104f7d4d9"><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface</a> () const</td></tr>
<tr class="memdesc:a4ce43974707a1894bb523f5104f7d4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default interface associated with this object.  <a href="#a4ce43974707a1894bb523f5104f7d4d9">More...</a><br /></td></tr>
<tr class="separator:a4ce43974707a1894bb523f5104f7d4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723b0433c976e9a7c5277034d3f9cd16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface</a> (const std::string &amp;new_default_name)</td></tr>
<tr class="memdesc:a723b0433c976e9a7c5277034d3f9cd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default interface to a specific name.  <a href="#a723b0433c976e9a7c5277034d3f9cd16">More...</a><br /></td></tr>
<tr class="separator:a723b0433c976e9a7c5277034d3f9cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51bf37df4f3de1747a8bd54a0602596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">remove_default_interface</a> ()</td></tr>
<tr class="memdesc:af51bf37df4f3de1747a8bd54a0602596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the currently set (if any) default interface.  <a href="#af51bf37df4f3de1747a8bd54a0602596">More...</a><br /></td></tr>
<tr class="separator:af51bf37df4f3de1747a8bd54a0602596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ac34aaa008ffaa627f1b7c3e1bed4e"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:a80ac34aaa008ffaa627f1b7c3e1bed4e"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a80ac34aaa008ffaa627f1b7c3e1bed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the default interface.  <a href="#a80ac34aaa008ffaa627f1b7c3e1bed4e">More...</a><br /></td></tr>
<tr class="separator:a80ac34aaa008ffaa627f1b7c3e1bed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6301542d8ee3697a590c0f2e4f71148"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr class="memitem:ad6301542d8ee3697a590c0f2e4f71148"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad6301542d8ee3697a590c0f2e4f71148">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad6301542d8ee3697a590c0f2e4f71148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the default interface.  <a href="#ad6301542d8ee3697a590c0f2e4f71148">More...</a><br /></td></tr>
<tr class="separator:ad6301542d8ee3697a590c0f2e4f71148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02db63f9d8b062add2027b3c87fa561"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aa02db63f9d8b062add2027b3c87fa561"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa02db63f9d8b062add2027b3c87fa561">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa02db63f9d8b062add2027b3c87fa561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the default interface.  <a href="#aa02db63f9d8b062add2027b3c87fa561">More...</a><br /></td></tr>
<tr class="separator:aa02db63f9d8b062add2027b3c87fa561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa596d815c2caa640f24e5b99afaac704"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:aa596d815c2caa640f24e5b99afaac704"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa596d815c2caa640f24e5b99afaac704">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa596d815c2caa640f24e5b99afaac704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the default interface.  <a href="#aa596d815c2caa640f24e5b99afaac704">More...</a><br /></td></tr>
<tr class="separator:aa596d815c2caa640f24e5b99afaac704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfc7e7ed9ea2bc5a27a84de002b8d4"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:aa2cfc7e7ed9ea2bc5a27a84de002b8d4"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa2cfc7e7ed9ea2bc5a27a84de002b8d4">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa2cfc7e7ed9ea2bc5a27a84de002b8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the default interface.  <a href="#aa2cfc7e7ed9ea2bc5a27a84de002b8d4">More...</a><br /></td></tr>
<tr class="separator:aa2cfc7e7ed9ea2bc5a27a84de002b8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076d912557296c0921e9169beddce8b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:a6076d912557296c0921e9169beddce8b"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a6076d912557296c0921e9169beddce8b">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6076d912557296c0921e9169beddce8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the default interface.  <a href="#a6076d912557296c0921e9169beddce8b">More...</a><br /></td></tr>
<tr class="separator:a6076d912557296c0921e9169beddce8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae08c0915d64e938e1f430288ae5218"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:a2ae08c0915d64e938e1f430288ae5218"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a2ae08c0915d64e938e1f430288ae5218">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2ae08c0915d64e938e1f430288ae5218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the default interface.  <a href="#a2ae08c0915d64e938e1f430288ae5218">More...</a><br /></td></tr>
<tr class="separator:a2ae08c0915d64e938e1f430288ae5218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bc11dad491e4b6a380917881bf99b3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:a41bc11dad491e4b6a380917881bf99b3"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a41bc11dad491e4b6a380917881bf99b3">create_signal</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a41bc11dad491e4b6a380917881bf99b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the default interface.  <a href="#a41bc11dad491e4b6a380917881bf99b3">More...</a><br /></td></tr>
<tr class="separator:a41bc11dad491e4b6a380917881bf99b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3744b7cf12e5ad540544c94213069a26"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:a3744b7cf12e5ad540544c94213069a26"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3744b7cf12e5ad540544c94213069a26">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a3744b7cf12e5ad540544c94213069a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the named interface.  <a href="#a3744b7cf12e5ad540544c94213069a26">More...</a><br /></td></tr>
<tr class="separator:a3744b7cf12e5ad540544c94213069a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec4db1560cf09d301bfd5fde76049bc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr class="memitem:a8ec4db1560cf09d301bfd5fde76049bc"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a8ec4db1560cf09d301bfd5fde76049bc">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a8ec4db1560cf09d301bfd5fde76049bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the named interface.  <a href="#a8ec4db1560cf09d301bfd5fde76049bc">More...</a><br /></td></tr>
<tr class="separator:a8ec4db1560cf09d301bfd5fde76049bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe81ebb954995638d6123f9420016ee5"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:abe81ebb954995638d6123f9420016ee5"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#abe81ebb954995638d6123f9420016ee5">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:abe81ebb954995638d6123f9420016ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the named interface.  <a href="#abe81ebb954995638d6123f9420016ee5">More...</a><br /></td></tr>
<tr class="separator:abe81ebb954995638d6123f9420016ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b064748a1791382dc787600de2e171b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:a1b064748a1791382dc787600de2e171b"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a1b064748a1791382dc787600de2e171b">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a1b064748a1791382dc787600de2e171b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the named interface.  <a href="#a1b064748a1791382dc787600de2e171b">More...</a><br /></td></tr>
<tr class="separator:a1b064748a1791382dc787600de2e171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abd93bdccef8871d5bccf21db647a8e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:a0abd93bdccef8871d5bccf21db647a8e"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0abd93bdccef8871d5bccf21db647a8e">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a0abd93bdccef8871d5bccf21db647a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the named interface.  <a href="#a0abd93bdccef8871d5bccf21db647a8e">More...</a><br /></td></tr>
<tr class="separator:a0abd93bdccef8871d5bccf21db647a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f950b1740ffe5e2c4c2fa77a2c2394"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ac2f950b1740ffe5e2c4c2fa77a2c2394"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ac2f950b1740ffe5e2c4c2fa77a2c2394">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:ac2f950b1740ffe5e2c4c2fa77a2c2394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the named interface.  <a href="#ac2f950b1740ffe5e2c4c2fa77a2c2394">More...</a><br /></td></tr>
<tr class="separator:ac2f950b1740ffe5e2c4c2fa77a2c2394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2636bdd3bfa8a7ac893a997483410b34"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:a2636bdd3bfa8a7ac893a997483410b34"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a2636bdd3bfa8a7ac893a997483410b34">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:a2636bdd3bfa8a7ac893a997483410b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the named interface.  <a href="#a2636bdd3bfa8a7ac893a997483410b34">More...</a><br /></td></tr>
<tr class="separator:a2636bdd3bfa8a7ac893a997483410b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e313fdf93a4d594d1d0ae352a5ec6"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:afb8e313fdf93a4d594d1d0ae352a5ec6"><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#afb8e313fdf93a4d594d1d0ae352a5ec6">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr class="memdesc:afb8e313fdf93a4d594d1d0ae352a5ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a signal with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the named interface.  <a href="#afb8e313fdf93a4d594d1d0ae352a5ec6">More...</a><br /></td></tr>
<tr class="separator:afb8e313fdf93a4d594d1d0ae352a5ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41849a351a01d2a48bf3f9ee1741f811"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a41849a351a01d2a48bf3f9ee1741f811">children</a> () const</td></tr>
<tr class="memdesc:a41849a351a01d2a48bf3f9ee1741f811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the children associated with this object instance.  <a href="#a41849a351a01d2a48bf3f9ee1741f811">More...</a><br /></td></tr>
<tr class="separator:a41849a351a01d2a48bf3f9ee1741f811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad199d75a39c818ddbe1c793125af3687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad199d75a39c818ddbe1c793125af3687">child</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ad199d75a39c818ddbe1c793125af3687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a named child of this object.  <a href="#ad199d75a39c818ddbe1c793125af3687">More...</a><br /></td></tr>
<tr class="separator:ad199d75a39c818ddbe1c793125af3687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f7709b0cc19d84ebca2236c717d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a059f7709b0cc19d84ebca2236c717d63">add_child</a> (const std::string &amp;name, <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> <a class="el" href="classDBus_1_1Object.html#ad199d75a39c818ddbe1c793125af3687">child</a>, bool force=false)</td></tr>
<tr class="memdesc:a059f7709b0cc19d84ebca2236c717d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set.  <a href="#a059f7709b0cc19d84ebca2236c717d63">More...</a><br /></td></tr>
<tr class="separator:a059f7709b0cc19d84ebca2236c717d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3515d2b48bd3f14aba2a06d77572d4cb">remove_child</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the named child from this object.  <a href="#a3515d2b48bd3f14aba2a06d77572d4cb">More...</a><br /></td></tr>
<tr class="separator:a3515d2b48bd3f14aba2a06d77572d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d045e64a7cba7e2fb6877385579bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">has_child</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a66d045e64a7cba7e2fb6877385579bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an object has a child with a specified name.  <a href="#a66d045e64a7cba7e2fb6877385579bf4">More...</a><br /></td></tr>
<tr class="separator:a66d045e64a7cba7e2fb6877385579bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a90a8ee8c991257ac19c56ca315893"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect</a> (int space_depth=0) const</td></tr>
<tr class="memdesc:a40a90a8ee8c991257ac19c56ca315893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespaceDBus.html">DBus</a> XML description of this interface.  <a href="#a40a90a8ee8c991257ac19c56ca315893">More...</a><br /></td></tr>
<tr class="separator:a40a90a8ee8c991257ac19c56ca315893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89d67b4b8edb63cbda1bba602abc5e"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9e89d67b4b8edb63cbda1bba602abc5e">signal_interface_added</a> ()</td></tr>
<tr class="memdesc:a9e89d67b4b8edb63cbda1bba602abc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when an interface is added to this object.  <a href="#a9e89d67b4b8edb63cbda1bba602abc5e">More...</a><br /></td></tr>
<tr class="separator:a9e89d67b4b8edb63cbda1bba602abc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47036e8bdd3468e2903ae33dfe5361e8"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a47036e8bdd3468e2903ae33dfe5361e8">signal_interface_removed</a> ()</td></tr>
<tr class="memdesc:a47036e8bdd3468e2903ae33dfe5361e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when an interface is removed from this object.  <a href="#a47036e8bdd3468e2903ae33dfe5361e8">More...</a><br /></td></tr>
<tr class="separator:a47036e8bdd3468e2903ae33dfe5361e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d62aab742803c50168e18115194bf7"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;,DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a66d62aab742803c50168e18115194bf7">signal_default_interface_changed</a> ()</td></tr>
<tr class="memdesc:a66d62aab742803c50168e18115194bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when the default interface of this object is changed.  <a href="#a66d62aab742803c50168e18115194bf7">More...</a><br /></td></tr>
<tr class="separator:a66d62aab742803c50168e18115194bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdab48091345e200f529521bcb98667"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; conn, <a class="el" href="classDBus_1_1Message.html#a30b9cd71b63f5c0b5b97c4cff35b1a69">Message::const_pointer</a> msg)</td></tr>
<tr class="memdesc:adfdab48091345e200f529521bcb98667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the specified message on the specified connection.  <a href="#adfdab48091345e200f529521bcb98667">More...</a><br /></td></tr>
<tr class="separator:adfdab48091345e200f529521bcb98667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0b8123fcd7da0638a6fa6d9f48d0102e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0b8123fcd7da0638a6fa6d9f48d0102e">create</a> (const std::string &amp;path=std::string(), <a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a> pf=<a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849aa2b21225bb78002bfc1db074574ee2fd">PRIMARY</a>)</td></tr>
<tr class="memdesc:a0b8123fcd7da0638a6fa6d9f48d0102e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named <a class="el" href="classDBus_1_1Object.html">Object</a> that will register as a primary or fallback handler.  <a href="#a0b8123fcd7da0638a6fa6d9f48d0102e">More...</a><br /></td></tr>
<tr class="separator:a0b8123fcd7da0638a6fa6d9f48d0102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5389375b09c7c05a0f03af84da24ba6f"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;,sigc::connection &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a></td></tr>
<tr class="separator:a5389375b09c7c05a0f03af84da24ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2dc063018105e5ddfe1df51f93659c28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a2dc063018105e5ddfe1df51f93659c28">Object</a> (const std::string &amp;path, <a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a> pf=<a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849aa2b21225bb78002bfc1db074574ee2fd">PRIMARY</a>)</td></tr>
<tr class="memdesc:a2dc063018105e5ddfe1df51f93659c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class has a protected constructor.  <a href="#a2dc063018105e5ddfe1df51f93659c28">More...</a><br /></td></tr>
<tr class="separator:a2dc063018105e5ddfe1df51f93659c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb58727e387a7e00d4f53f0793e805e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed</a> (const std::string &amp;oldname, const std::string &amp;newname, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface</a>)</td></tr>
<tr class="memdesc:a0fb58727e387a7e00d4f53f0793e805e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback point that updates the interface name map when an interface changes its name.  <a href="#a0fb58727e387a7e00d4f53f0793e805e">More...</a><br /></td></tr>
<tr class="separator:a0fb58727e387a7e00d4f53f0793e805e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3f713d2810dab3129e5dc8f3bb51f495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a></td></tr>
<tr class="separator:a3f713d2810dab3129e5dc8f3bb51f495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74374aa2b53adad6cb6da0d7b16f5306"><td class="memItemLeft" align="right" valign="top">pthread_rwlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a></td></tr>
<tr class="separator:a74374aa2b53adad6cb6da0d7b16f5306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684bfb2a817c1ef979753ada9b5e02f3"><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a684bfb2a817c1ef979753ada9b5e02f3">m_name_mutex</a></td></tr>
<tr class="separator:a684bfb2a817c1ef979753ada9b5e02f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa20c2b2547eb1463e07f4bb2a8ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a></td></tr>
<tr class="separator:a43fa20c2b2547eb1463e07f4bb2a8ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b564bf7c2079dbe307543145de4474"><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a></td></tr>
<tr class="separator:ad3b564bf7c2079dbe307543145de4474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79375a3991daa872acbed92cebd634a1"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;,DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a></td></tr>
<tr class="separator:a79375a3991daa872acbed92cebd634a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313ca46702beaa5b2de7ba9f199b58e9"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a313ca46702beaa5b2de7ba9f199b58e9">m_signal_interface_added</a></td></tr>
<tr class="separator:a313ca46702beaa5b2de7ba9f199b58e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd04dd8c3d1dc8eb3e24a8c669e3418"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a1cd04dd8c3d1dc8eb3e24a8c669e3418">m_signal_interface_removed</a></td></tr>
<tr class="separator:a1cd04dd8c3d1dc8eb3e24a8c669e3418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadf56908734af799a62a2797f2f5cc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">m_interface_signal_name_connections</a></td></tr>
<tr class="separator:aeadf56908734af799a62a2797f2f5cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>TODO rethink whether it might be beneficial to have multiple connections for one object</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Rick L Vinyard Jr <a href="#" onclick="location.href='mai'+'lto:'+'rvi'+'ny'+'ard'+'@c'+'s.n'+'ms'+'u.e'+'du'; return false;">rviny<span style="display: none;">.nosp@m.</span>ard@<span style="display: none;">.nosp@m.</span>cs.nm<span style="display: none;">.nosp@m.</span>su.e<span style="display: none;">.nosp@m.</span>du</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="callee_object_inherited_8cpp-example.html#_a0">callee_object_inherited.cpp</a>, and <a class="el" href="signal_emitter_object_8cpp-example.html#_a0">signal_emitter_object.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3deca17387532da99bdc7f1f23812046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deca17387532da99bdc7f1f23812046">&#9670;&nbsp;</a></span>Children</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&gt; <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">DBus::Object::Children</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's children. </p>
<p>The <em>key</em> is the child's name and the <em>value</em> </p>
<p><b>Data</b> <b>Structure</b> - map: an object's children must be uniquely named <b>Key</b> - child name <b>Value</b> -smart pointer to a child object.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046" title="Typedef to storage structure for an Object instance&#39;s children. ">Object::Children</a></code> </p>

</div>
</div>
<a id="a3dd597323a47e73d511c8d55e271fb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd597323a47e73d511c8d55e271fb83">&#9670;&nbsp;</a></span>Interfaces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::multimap&lt;std::string, DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">DBus::Object::Interfaces</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's interfaces. </p>
<p><b>Data</b> <b>Structure</b> - Multimap: There is no restriction that interfaces must be uniquely named <b>Key</b> - interface name <b>Value</b> -smart pointer to an interface.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83" title="Typedef to the storage structure for an Object instance&#39;s interfaces. ">Object::Interfaces</a></code> </p>

</div>
</div>
<a id="a5389375b09c7c05a0f03af84da24ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5389375b09c7c05a0f03af84da24ba6f">&#9670;&nbsp;</a></span>InterfaceSignalNameConnections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; ,sigc::connection&gt; <a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">DBus::Object::InterfaceSignalNameConnections</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bf674b9935ccede5a0cc5c9e5edfbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf674b9935ccede5a0cc5c9e5edfbc4">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Object.html">Object</a>&gt; <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">DBus::Object::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to smart pointers to <a class="el" href="classDBus_1_1Object.html">Object</a>. </p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4" title="Typedef to smart pointers to Object. ">Object::pointer</a></code> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="callee_object_inherited_8cpp-example.html#a1">callee_object_inherited.cpp</a>, and <a class="el" href="signal_emitter_object_8cpp-example.html#a1">signal_emitter_object.cpp</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2dc063018105e5ddfe1df51f93659c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc063018105e5ddfe1df51f93659c28">&#9670;&nbsp;</a></span>Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a>&#160;</td>
          <td class="paramname"><em>pf</em> = <code><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849aa2b21225bb78002bfc1db074574ee2fd">PRIMARY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class has a protected constructor. </p>
<p>Use the <code><a class="el" href="classDBus_1_1Object.html#a0b8123fcd7da0638a6fa6d9f48d0102e" title="Creates a named Object that will register as a primary or fallback handler. ">create()</a></code> methods to obtain a smart pointer to a new instance. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, and <a class="el" href="classDBus_1_1Object.html#a684bfb2a817c1ef979753ada9b5e02f3">m_name_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a0b8123fcd7da0638a6fa6d9f48d0102e">create()</a>.</p>

</div>
</div>
<a id="a22eb06f7f4cbed84f434d8a26b56dded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eb06f7f4cbed84f434d8a26b56dded">&#9670;&nbsp;</a></span>~Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::~Object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, and <a class="el" href="classDBus_1_1Object.html#a684bfb2a817c1ef979753ada9b5e02f3">m_name_mutex</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a059f7709b0cc19d84ebca2236c717d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059f7709b0cc19d84ebca2236c717d63">&#9670;&nbsp;</a></span>add_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the child was successfully added, <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to use for the child. </td></tr>
    <tr><td class="paramname">child</td><td>A smart pointer to an object to add as a child. </td></tr>
    <tr><td class="paramname">force</td><td>If <code>true</code> a child with the same name will be replaced. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ad199d75a39c818ddbe1c793125af3687">child()</a>, <a class="el" href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">has_child()</a>, and <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>.</p>

</div>
</div>
<a id="a34967617b0b59cfb8f861ec2dab7ad2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34967617b0b59cfb8f861ec2dab7ad2e">&#9670;&nbsp;</a></span>add_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_interface </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the interface to this object. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, <a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">m_interface_signal_name_connections</a>, <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, <a class="el" href="classDBus_1_1Object.html#a313ca46702beaa5b2de7ba9f199b58e9">m_signal_interface_added</a>, <a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed()</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>.</p>

</div>
</div>
<a id="ad199d75a39c818ddbe1c793125af3687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad199d75a39c818ddbe1c793125af3687">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> DBus::Object::child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a named child of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to a child with the specified name, or a null smart pointer if no child found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to return </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a059f7709b0cc19d84ebca2236c717d63">add_child()</a>.</p>

</div>
</div>
<a id="a41849a351a01d2a48bf3f9ee1741f811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41849a351a01d2a48bf3f9ee1741f811">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Object::Children</a> &amp; DBus::Object::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the children associated with this object instance. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>.</p>

</div>
</div>
<a id="a0b8123fcd7da0638a6fa6d9f48d0102e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8123fcd7da0638a6fa6d9f48d0102e">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> DBus::Object::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a>&#160;</td>
          <td class="paramname"><em>pf</em> = <code><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849aa2b21225bb78002bfc1db074574ee2fd">PRIMARY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a named <a class="el" href="classDBus_1_1Object.html">Object</a> that will register as a primary or fallback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path the object will handle </td></tr>
    <tr><td class="paramname">pf</td><td>Determines whether the <a class="el" href="classDBus_1_1Object.html">Object</a> will registar as a primary or fallback handler (<em>default</em> = <code>PRIMARY</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="callee_object_inherited_8cpp-example.html#a2">callee_object_inherited.cpp</a>, and <a class="el" href="signal_emitter_object_8cpp-example.html#a2">signal_emitter_object.cpp</a>.</dd>
</dl>
<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a2dc063018105e5ddfe1df51f93659c28">Object()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Connection.html#a0d507437e6fa86220e59247c19cc420a">DBus::Connection::create_object()</a>.</p>

</div>
</div>
<a id="a76111752ea7a0d59549a9d95be03bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76111752ea7a0d59549a9d95be03bd69">&#9670;&nbsp;</a></span>create_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::create_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and adds the named interface to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the newly created interface </dd></dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Interface.html#a54d09d2890f0ecefc3dbc49bc49f5081">DBus::Interface::create()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a652697db4c23d9afffeb7e94608258f6">create_method()</a>, and <a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e">create_signal()</a>.</p>

</div>
</div>
<a id="a652697db4c23d9afffeb7e94608258f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652697db4c23d9afffeb7e94608258f6">&#9670;&nbsp;</a></span>create_method() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot0&lt; T_return &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="ac80235f6723372fb3d54763a54f8c723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80235f6723372fb3d54763a54f8c723">&#9670;&nbsp;</a></span>create_method() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot1&lt; T_return, T_arg1 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a505de25301f877951c1cec0665afbf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505de25301f877951c1cec0665afbf7d">&#9670;&nbsp;</a></span>create_method() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a9a4b07f1189b697116c2ef385aa88317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4b07f1189b697116c2ef385aa88317">&#9670;&nbsp;</a></span>create_method() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a7eb8d86968cb7e329e8e6e85dc333aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb8d86968cb7e329e8e6e85dc333aaa">&#9670;&nbsp;</a></span>create_method() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a503d26fd444c811e7592ef9fbea35831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503d26fd444c811e7592ef9fbea35831">&#9670;&nbsp;</a></span>create_method() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="afdddd4b9a052dc94281f29f12a299aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdddd4b9a052dc94281f29f12a299aae">&#9670;&nbsp;</a></span>create_method() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a54c6c691004d71f8cb1091aacd9d12b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6c691004d71f8cb1091aacd9d12b6">&#9670;&nbsp;</a></span>create_method() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="ac2455129cef407ce2a57dc687996607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2455129cef407ce2a57dc687996607c">&#9670;&nbsp;</a></span>create_method() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot0&lt; T_return &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a68b5237cdc1aa298e4742b2c886e089d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b5237cdc1aa298e4742b2c886e089d">&#9670;&nbsp;</a></span>create_method() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot1&lt; T_return, T_arg1 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="ac93759dd3f7ec9c01a7d8e5ea1342858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93759dd3f7ec9c01a7d8e5ea1342858">&#9670;&nbsp;</a></span>create_method() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a5158816dc5f27782dc5ec7a1ec5baced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5158816dc5f27782dc5ec7a1ec5baced">&#9670;&nbsp;</a></span>create_method() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a5879c601f0402ad02a0be4b78ba46734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5879c601f0402ad02a0be4b78ba46734">&#9670;&nbsp;</a></span>create_method() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="ac0381d96cf4e182ca91c5fd85f9935c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0381d96cf4e182ca91c5fd85f9935c1">&#9670;&nbsp;</a></span>create_method() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a69f300c3cff03cfa29c200a70ae45a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f300c3cff03cfa29c200a70ae45a51">&#9670;&nbsp;</a></span>create_method() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a78a8e16941666dca415a63dcf9a95f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a8e16941666dca415a63dcf9a95f65">&#9670;&nbsp;</a></span>create_method() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_name</td><td>The <a class="el" href="namespaceDBus.html">DBus</a> interface, in org.example.Foo style </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method that this is for. </td></tr>
    <tr><td class="paramname">slot</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a80ac34aaa008ffaa627f1b7c3e1bed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ac34aaa008ffaa627f1b7c3e1bed4e">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="ad6301542d8ee3697a590c0f2e4f71148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6301542d8ee3697a590c0f2e4f71148">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="aa02db63f9d8b062add2027b3c87fa561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02db63f9d8b062add2027b3c87fa561">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="aa596d815c2caa640f24e5b99afaac704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa596d815c2caa640f24e5b99afaac704">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="aa2cfc7e7ed9ea2bc5a27a84de002b8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cfc7e7ed9ea2bc5a27a84de002b8d4">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="a6076d912557296c0921e9169beddce8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6076d912557296c0921e9169beddce8b">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="a2ae08c0915d64e938e1f430288ae5218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae08c0915d64e938e1f430288ae5218">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="a41bc11dad491e4b6a380917881bf99b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bc11dad491e4b6a380917881bf99b3">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the default interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>.</p>

</div>
</div>
<a id="a3744b7cf12e5ad540544c94213069a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3744b7cf12e5ad540544c94213069a26">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a8ec4db1560cf09d301bfd5fde76049bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec4db1560cf09d301bfd5fde76049bc">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="abe81ebb954995638d6123f9420016ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe81ebb954995638d6123f9420016ee5">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a1b064748a1791382dc787600de2e171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b064748a1791382dc787600de2e171b">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a0abd93bdccef8871d5bccf21db647a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abd93bdccef8871d5bccf21db647a8e">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="ac2f950b1740ffe5e2c4c2fa77a2c2394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f950b1740ffe5e2c4c2fa77a2c2394">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a2636bdd3bfa8a7ac893a997483410b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2636bdd3bfa8a7ac893a997483410b34">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="afb8e313fdf93a4d594d1d0ae352a5ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8e313fdf93a4d594d1d0ae352a5ec6">&#9670;&nbsp;</a></span>create_signal() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a signal with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the named interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created signal</dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it to the default int...">create_signal()</a></code> call will determine the signature of the signal created. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>.</p>

</div>
</div>
<a id="a4ce43974707a1894bb523f5104f7d4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce43974707a1894bb523f5104f7d4d9">&#9670;&nbsp;</a></span>default_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::default_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default interface associated with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>The default interface, or a null smart pointer if no default is set </dd></dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a80ac34aaa008ffaa627f1b7c3e1bed4e">create_signal()</a>.</p>

</div>
</div>
<a id="adfdab48091345e200f529521bcb98667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdab48091345e200f529521bcb98667">&#9670;&nbsp;</a></span>handle_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a> DBus::Object::handle_message </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDBus_1_1Message.html#a30b9cd71b63f5c0b5b97c4cff35b1a69">Message::const_pointer</a>&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the specified message on the specified connection. </p>
<p>If <code>msg</code> is an introspection message, the object will rely on its <code>introspection()</code> method to provide a reply.</p>
<p>Looks for interfaces specified in the message first. If the message does not specify an interface or the specified interface is not found the default interface will be used.</p>
<p>If the specified interface is found, all matching interfaces will be tried until an interface handler returns <code>HANDLED</code>. Once an interface returns <code>HANDLED</code> no further interfaces will be tried.</p>
<p>If no interface returns <code>HANDLED</code> the default interface (if one is set) will be tried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>HANDLED</code> if this object handled the message, <code>NOT_HANDLED</code> otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The <a class="el" href="classDBus_1_1Connection.html" title="Connection point to the DBus. ">Connection</a> to send the reply message on </td></tr>
    <tr><td class="paramname">msg</td><td>The message to handle; must be a <a class="el" href="classDBus_1_1CallMessage.html" title="Represents a DBus call message. ">CallMessage</a> or it will not be handled </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classDBus_1_1MessageHandler.html#adcc82cf431e790efa9be7719aaf8ea00">DBus::MessageHandler</a>.</p>

<p class="reference">References <a class="el" href="classDBus_1_1CallMessage.html#a260417008d455a9dd8f71da794c1f810">DBus::CallMessage::create()</a>, <a class="el" href="utility_8h.html#a52e0100c1343c07557166c73a2a11661">DBUS_CXX_INTROSPECTABLE_INTERFACE</a>, <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0af6d81c3b78788257e17f2c5852d6beab">DBus::HANDLED</a>, <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, and <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0a6b7b1c5651a648f0767234dd7d5dc805">DBus::NOT_HANDLED</a>.</p>

</div>
</div>
<a id="a66d045e64a7cba7e2fb6877385579bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d045e64a7cba7e2fb6877385579bf4">&#9670;&nbsp;</a></span>has_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether an object has a child with a specified name. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the object has the named child, <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a059f7709b0cc19d84ebca2236c717d63">add_child()</a>.</p>

</div>
</div>
<a id="a9ec6e59d6996734e49cb53e01acfb767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec6e59d6996734e49cb53e01acfb767">&#9670;&nbsp;</a></span>has_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether an <a class="el" href="classDBus_1_1Object.html">Object</a> has a named interface. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the object has the named interface, <code>false</code> otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the interface to look for </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, and <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a3744b7cf12e5ad540544c94213069a26">create_signal()</a>.</p>

</div>
</div>
<a id="a6c348a2a12608d9a15db01e4b652e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c348a2a12608d9a15db01e4b652e132">&#9670;&nbsp;</a></span>interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first interface with the given name. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, and <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface()</a>, <a class="el" href="classDBus_1_1Object.html#ac2455129cef407ce2a57dc687996607c">create_method()</a>, <a class="el" href="classDBus_1_1Object.html#a3744b7cf12e5ad540544c94213069a26">create_signal()</a>, <a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message()</a>, <a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed()</a>, and <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>.</p>

</div>
</div>
<a id="a4e4359771c176e0bb0b38988c7616ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4359771c176e0bb0b38988c7616ca8">&#9670;&nbsp;</a></span>interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Object::Interfaces</a> &amp; DBus::Object::interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html">Object</a> instance. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>.</p>

</div>
</div>
<a id="a40a90a8ee8c991257ac19c56ca315893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a90a8ee8c991257ac19c56ca315893">&#9670;&nbsp;</a></span>introspect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DBus::Object::introspect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>space_depth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespaceDBus.html">DBus</a> XML description of this interface. </p>

<p class="reference">References <a class="el" href="utility_8h.html#a52e0100c1343c07557166c73a2a11661">DBUS_CXX_INTROSPECTABLE_INTERFACE</a>, <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>, and <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message()</a>.</p>

</div>
</div>
<a id="a0fb58727e387a7e00d4f53f0793e805e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb58727e387a7e00d4f53f0793e805e">&#9670;&nbsp;</a></span>on_interface_name_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::on_interface_name_changed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback point that updates the interface name map when an interface changes its name. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">m_interface_signal_name_connections</a>, <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, and <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>.</p>

</div>
</div>
<a id="ac2de7bda76136ba0ee003dc2a34446e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de7bda76136ba0ee003dc2a34446e7">&#9670;&nbsp;</a></span>register_with_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::register_with_connection </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends base version to include registering signals. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>, and <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>.</p>

</div>
</div>
<a id="a3515d2b48bd3f14aba2a06d77572d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3515d2b48bd3f14aba2a06d77572d4cb">&#9670;&nbsp;</a></span>remove_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::remove_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the named child from this object. </p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the child was found and removed, <code>false</code> if no child by the name was found to remove. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the child to remove. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a>.</p>

</div>
</div>
<a id="af51bf37df4f3de1747a8bd54a0602596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51bf37df4f3de1747a8bd54a0602596">&#9670;&nbsp;</a></span>remove_default_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_default_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the currently set (if any) default interface. </p>
<p>There wil not be a default interface set. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, and <a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a>.</p>

</div>
</div>
<a id="aabbcd801c315e2e88a39b6654bceedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbcd801c315e2e88a39b6654bceedef">&#9670;&nbsp;</a></span>remove_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first interface found with the given name. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, <a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">m_interface_signal_name_connections</a>, <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, <a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a>, and <a class="el" href="classDBus_1_1Object.html#a1cd04dd8c3d1dc8eb3e24a8c669e3418">m_signal_interface_removed</a>.</p>

</div>
</div>
<a id="a723b0433c976e9a7c5277034d3f9cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723b0433c976e9a7c5277034d3f9cd16">&#9670;&nbsp;</a></span>set_default_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::set_default_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_default_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default interface to a specific name. </p>
<p>The first interface found with a matching name is used. If there is already a default interface set it will be replaced.</p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if an interface with the specified name was found, <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_default_name</td><td>The name of the interface to use as the default. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a>, <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a>, <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a>, and <a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a652697db4c23d9afffeb7e94608258f6">create_method()</a>.</p>

</div>
</div>
<a id="a66d62aab742803c50168e18115194bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d62aab742803c50168e18115194bf7">&#9670;&nbsp;</a></span>signal_default_interface_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a>, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_default_interface_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal emitted when the default interface of this object is changed. </p>
<p>The first parameter of the callback is a pointer to the old default interface, and the second parameter is a callback to the new default interface. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a>.</p>

</div>
</div>
<a id="a9e89d67b4b8edb63cbda1bba602abc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89d67b4b8edb63cbda1bba602abc5e">&#9670;&nbsp;</a></span>signal_interface_added()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_interface_added </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal emitted when an interface is added to this object. </p>
<p>The first parameter of the callback is a pointer to the newly added interface. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a313ca46702beaa5b2de7ba9f199b58e9">m_signal_interface_added</a>.</p>

</div>
</div>
<a id="a47036e8bdd3468e2903ae33dfe5361e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47036e8bdd3468e2903ae33dfe5361e8">&#9670;&nbsp;</a></span>signal_interface_removed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_interface_removed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal emitted when an interface is removed from this object. </p>
<p>The first parameter of the callback is a pointer to the removed interface. </p>

<p class="reference">References <a class="el" href="classDBus_1_1Object.html#a1cd04dd8c3d1dc8eb3e24a8c669e3418">m_signal_interface_removed</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f713d2810dab3129e5dc8f3bb51f495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f713d2810dab3129e5dc8f3bb51f495">&#9670;&nbsp;</a></span>m_children</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a> DBus::Object::m_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a059f7709b0cc19d84ebca2236c717d63">add_child()</a>, <a class="el" href="classDBus_1_1Object.html#ad199d75a39c818ddbe1c793125af3687">child()</a>, <a class="el" href="classDBus_1_1Object.html#a41849a351a01d2a48bf3f9ee1741f811">children()</a>, <a class="el" href="classDBus_1_1Object.html#a66d045e64a7cba7e2fb6877385579bf4">has_child()</a>, <a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect()</a>, <a class="el" href="classDBus_1_1Object.html#ac2de7bda76136ba0ee003dc2a34446e7">register_with_connection()</a>, and <a class="el" href="classDBus_1_1Object.html#a3515d2b48bd3f14aba2a06d77572d4cb">remove_child()</a>.</p>

</div>
</div>
<a id="ad3b564bf7c2079dbe307543145de4474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b564bf7c2079dbe307543145de4474">&#9670;&nbsp;</a></span>m_default_interface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; DBus::Object::m_default_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a652697db4c23d9afffeb7e94608258f6">create_method()</a>, <a class="el" href="classDBus_1_1Object.html#a4ce43974707a1894bb523f5104f7d4d9">default_interface()</a>, <a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message()</a>, <a class="el" href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">remove_default_interface()</a>, <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="aeadf56908734af799a62a2797f2f5cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadf56908734af799a62a2797f2f5cc9">&#9670;&nbsp;</a></span>m_interface_signal_name_connections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a> DBus::Object::m_interface_signal_name_connections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed()</a>, and <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>.</p>

</div>
</div>
<a id="a43fa20c2b2547eb1463e07f4bb2a8ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fa20c2b2547eb1463e07f4bb2a8ff9">&#9670;&nbsp;</a></span>m_interfaces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a> DBus::Object::m_interfaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#a4e4359771c176e0bb0b38988c7616ca8">interfaces()</a>, <a class="el" href="classDBus_1_1Object.html#a40a90a8ee8c991257ac19c56ca315893">introspect()</a>, <a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed()</a>, <a class="el" href="classDBus_1_1Object.html#ac2de7bda76136ba0ee003dc2a34446e7">register_with_connection()</a>, <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>.</p>

</div>
</div>
<a id="a74374aa2b53adad6cb6da0d7b16f5306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74374aa2b53adad6cb6da0d7b16f5306">&#9670;&nbsp;</a></span>m_interfaces_rwlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_rwlock_t DBus::Object::m_interfaces_rwlock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, <a class="el" href="classDBus_1_1Object.html#adfdab48091345e200f529521bcb98667">handle_message()</a>, <a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a6c348a2a12608d9a15db01e4b652e132">interface()</a>, <a class="el" href="classDBus_1_1Object.html#a2dc063018105e5ddfe1df51f93659c28">Object()</a>, <a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed()</a>, <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a22eb06f7f4cbed84f434d8a26b56dded">~Object()</a>.</p>

</div>
</div>
<a id="a684bfb2a817c1ef979753ada9b5e02f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684bfb2a817c1ef979753ada9b5e02f3">&#9670;&nbsp;</a></span>m_name_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t DBus::Object::m_name_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a2dc063018105e5ddfe1df51f93659c28">Object()</a>, and <a class="el" href="classDBus_1_1Object.html#a22eb06f7f4cbed84f434d8a26b56dded">~Object()</a>.</p>

</div>
</div>
<a id="a79375a3991daa872acbed92cebd634a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79375a3991daa872acbed92cebd634a1">&#9670;&nbsp;</a></span>m_signal_default_interface_changed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; ,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; DBus::Object::m_signal_default_interface_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">remove_default_interface()</a>, <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>, <a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a66d62aab742803c50168e18115194bf7">signal_default_interface_changed()</a>.</p>

</div>
</div>
<a id="a313ca46702beaa5b2de7ba9f199b58e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313ca46702beaa5b2de7ba9f199b58e9">&#9670;&nbsp;</a></span>m_signal_interface_added</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; DBus::Object::m_signal_interface_added</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a9e89d67b4b8edb63cbda1bba602abc5e">signal_interface_added()</a>.</p>

</div>
</div>
<a id="a1cd04dd8c3d1dc8eb3e24a8c669e3418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd04dd8c3d1dc8eb3e24a8c669e3418">&#9670;&nbsp;</a></span>m_signal_interface_removed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; DBus::Object::m_signal_interface_removed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface()</a>, and <a class="el" href="classDBus_1_1Object.html#a47036e8bdd3468e2903ae33dfe5361e8">signal_interface_removed()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="object_8h_source.html">object.h</a></li>
<li><a class="el" href="object_8cpp.html">object.cpp</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Wed Feb 12 2020 22:28:11 for dbus-cxx by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.13</small></address>
</body>
</html>
